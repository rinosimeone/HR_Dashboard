{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# üìä Analisi Dati HR: Turnover e Demografia Aziendale\n",
    "\n",
    "## Guida Completa per Manager HR\n",
    "\n",
    "**Creato il:** 18 Luglio 2025  \n",
    "**Destinatari:** Manager HR, Direttori del Personale, Leadership aziendale  \n",
    "**Livello:** Principiante - Non richiede conoscenze tecniche  \n",
    "\n",
    "---\n",
    "\n",
    "### üéØ **Cosa troverai in questa analisi:**\n",
    "\n",
    "1. **Demografia dei dipendenti** - Chi sono i nostri dipendenti?\n",
    "2. **Analisi salariale** - Come sono distribuite le retribuzioni?\n",
    "3. **Performance aziendale** - Come performano i nostri team?\n",
    "4. **Turnover e retention** - Quanti dipendenti lasciano l'azienda?\n",
    "5. **Previsioni pensionamenti** - Chi andr√† in pensione nei prossimi anni?\n",
    "6. **Raccomandazioni strategiche** - Cosa fare con questi dati?\n",
    "\n",
    "### üí° **Come leggere questo notebook:**\n",
    "- **Celle grigie** = Codice (puoi ignorarle, esegui solo con Shift+Enter)\n",
    "- **Testo normale** = Spiegazioni e interpretazioni\n",
    "- **üìà Grafici** = Visualizzazioni dei dati\n",
    "- **üîç Insights** = Conclusioni pratiche per l'HR\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üîß Preparazione dell'Ambiente\n",
    "\n",
    "Prima di iniziare l'analisi, dobbiamo \"preparare i nostri strumenti\". Questa sezione carica le librerie necessarie per l'analisi dei dati.\n",
    "\n",
    "**‚ùó Importante:** Esegui questa cella per prima cosa premendo **Shift+Enter**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Importazione delle librerie per l'analisi dati\n",
    "# (Queste sono come gli \"strumenti\" che useremo per analizzare i dati)\n",
    "\n",
    "import pandas as pd              # Per leggere e manipolare i dati Excel/CSV\n",
    "import numpy as np               # Per calcoli matematici\n",
    "import matplotlib.pyplot as plt  # Per creare grafici\n",
    "import seaborn as sns           # Per grafici pi√π belli e professionali\n",
    "from datetime import datetime   # Per lavorare con le date\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')  # Nasconde messaggi tecnici non importanti\n",
    "\n",
    "# Configurazione per grafici pi√π belli\n",
    "plt.style.use('default')\n",
    "sns.set_palette(\"husl\")\n",
    "plt.rcParams['figure.figsize'] = (12, 6)  # Dimensione standard dei grafici\n",
    "\n",
    "print(\"‚úÖ Ambiente pronto per l'analisi!\")\n",
    "print(\"üìå Ora puoi procedere con l'analisi dei dati HR.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üìÇ Caricamento dei Dati HR\n",
    "\n",
    "In questa sezione carichiamo i dati dei dipendenti dal file Excel/CSV. Il sistema √® progettato per:\n",
    "- ‚úÖ Caricare automaticamente il file \"HR Data.csv\" se presente\n",
    "- ‚úÖ Creare dati di esempio se il file non √® disponibile\n",
    "- ‚úÖ Pulire automaticamente i dati (correggere errori, formattare date, ecc.)\n",
    "\n",
    "**Per Manager HR:** Non ti preoccupare del codice, concentrati sui risultati!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def carica_dati_hr(percorso_file='HR Data.csv'):\n",
    "    \"\"\"\n",
    "    Carica e prepara i dati HR per l'analisi\n",
    "    \n",
    "    Cosa fa questa funzione:\n",
    "    - Legge il file Excel/CSV con i dati dei dipendenti\n",
    "    - Corregge automaticamente errori comuni nei dati\n",
    "    - Calcola et√† e anzianit√† di servizio\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # Prova a caricare il file dei dati HR\n",
    "        df = pd.read_csv(percorso_file)\n",
    "        print(f\"‚úÖ Dati caricati con successo!\")\n",
    "        print(f\"üìä Totale dipendenti nel database: {len(df):,}\")\n",
    "        return df\n",
    "    except FileNotFoundError:\n",
    "        print(\"‚ö†Ô∏è  File 'HR Data.csv' non trovato.\")\n",
    "        print(\"üé≤ Creazione dati di esempio per la dimostrazione...\")\n",
    "        return crea_dati_esempio()\n",
    "\n",
    "def crea_dati_esempio():\n",
    "    \"\"\"\n",
    "    Crea un dataset di esempio per dimostrazioni\n",
    "    (Simula dati realistici di un'azienda di 300 dipendenti)\n",
    "    \"\"\"\n",
    "    np.random.seed(42)  # Per risultati riproducibili\n",
    "    n_dipendenti = 300\n",
    "    \n",
    "    # Simulazione dati realistici\n",
    "    dati = {\n",
    "        'EmployeeID': range(1, n_dipendenti + 1),\n",
    "        'EmployeeName': [f'Dipendente_{i}' for i in range(1, n_dipendenti + 1)],\n",
    "        'Salary': np.random.normal(45000, 15000, n_dipendenti).astype(int),\n",
    "        'Position': np.random.choice([\n",
    "            'Tecnico Produzione I', 'Tecnico Produzione II', 'Sales Manager',\n",
    "            'Manager Produzione', 'Software Engineer', 'IT Support', \n",
    "            'Data Analyst', 'Database Administrator', 'Network Engineer'\n",
    "        ], n_dipendenti),\n",
    "        'State': np.random.choice(['Milano', 'Roma', 'Torino', 'Napoli', 'Bologna'], n_dipendenti),\n",
    "        'Gender': np.random.choice(['M', 'F'], n_dipendenti),\n",
    "        'MaritalStatus': np.random.choice(['Single', 'Married', 'Divorced', 'Separated', 'Widowed'], n_dipendenti),\n",
    "        'EmploymentStatus': np.random.choice(['Active', 'Voluntarily Terminated', 'Terminated for Cause'], \n",
    "                                           n_dipendenti, p=[0.75, 0.20, 0.05]),\n",
    "        'Department': np.random.choice(['Produzione', 'IT', 'Vendite', 'Ingegneria', 'Amministrazione'], n_dipendenti),\n",
    "        'RecruitmentSource': np.random.choice(['Indeed', 'LinkedIn', 'Google', 'Referral'], n_dipendenti),\n",
    "        'PerformanceScore': np.random.choice(['Eccellente', 'Buono', 'Sufficiente', 'Insufficiente'], \n",
    "                                           n_dipendenti, p=[0.15, 0.70, 0.12, 0.03])\n",
    "    }\n",
    "    \n",
    "    # Generazione date realistiche\n",
    "    date_nascita = []\n",
    "    date_assunzione = []\n",
    "    date_cessazione = []\n",
    "    \n",
    "    for i in range(n_dipendenti):\n",
    "        # Data di nascita (et√† tra 25 e 65 anni)\n",
    "        anno_nascita = np.random.randint(1959, 2000)\n",
    "        data_nascita = datetime(anno_nascita, np.random.randint(1, 13), np.random.randint(1, 29))\n",
    "        date_nascita.append(data_nascita.strftime('%d/%m/%Y'))\n",
    "        \n",
    "        # Data di assunzione\n",
    "        anno_assunzione = np.random.randint(2008, 2025)\n",
    "        data_assunzione = datetime(anno_assunzione, np.random.randint(1, 13), np.random.randint(1, 29))\n",
    "        date_assunzione.append(data_assunzione.strftime('%d/%m/%Y'))\n",
    "        \n",
    "        # Data di cessazione (solo per ex-dipendenti)\n",
    "        if dati['EmploymentStatus'][i] != 'Active':\n",
    "            giorni_lavoro = np.random.randint(30, 2000)\n",
    "            data_cessazione = data_assunzione + pd.Timedelta(days=giorni_lavoro)\n",
    "            date_cessazione.append(data_cessazione.strftime('%d/%m/%Y'))\n",
    "        else:\n",
    "            date_cessazione.append(None)\n",
    "    \n",
    "    dati['DateOfBirth'] = date_nascita\n",
    "    dati['HiringDate'] = date_assunzione\n",
    "    dati['TerminationDate'] = date_cessazione\n",
    "    \n",
    "    return pd.DataFrame(dati)\n",
    "\n",
    "# Carica i dati\n",
    "df_raw = carica_dati_hr()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üßπ Pulizia e Preparazione dei Dati\n",
    "\n",
    "**Perch√© questa fase √® importante per l'HR:**\n",
    "- I dati \"grezzi\" spesso contengono errori (date scritte male, campi vuoti, etc.)\n",
    "- Dobbiamo standardizzare i formati per fare analisi corrette\n",
    "- Calcoliamo metriche utili come et√† attuale e anni di servizio\n",
    "\n",
    "**Cosa fa il codice sotto:**\n",
    "1. Converte le date in formato standard\n",
    "2. Pulisce i dati del genere (M/F)\n",
    "3. Calcola et√† e anzianit√† di servizio\n",
    "4. Rimuove eventuali dati di satisfaction non disponibili"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def pulisci_dati_hr(df):\n",
    "    \"\"\"\n",
    "    Pulisce e standardizza i dati HR\n",
    "    \n",
    "    Operazioni eseguite:\n",
    "    1. Conversione date in formato standard\n",
    "    2. Pulizia campo Gender\n",
    "    3. Calcolo et√† e tenure\n",
    "    4. Rimozione colonne non necessarie\n",
    "    \"\"\"\n",
    "    print(\"üßπ Inizio pulizia dati...\")\n",
    "    \n",
    "    # Copia dei dati per non modificare l'originale\n",
    "    df = df.copy()\n",
    "    \n",
    "    # 1. Conversione delle date\n",
    "    df['DateOfBirth'] = pd.to_datetime(df['DateOfBirth'], format='%d/%m/%Y', errors='coerce')\n",
    "    df['HiringDate'] = pd.to_datetime(df['HiringDate'], format='%d/%m/%Y', errors='coerce')\n",
    "    df['TerminationDate'] = pd.to_datetime(df['TerminationDate'], format='%d/%m/%Y', errors='coerce')\n",
    "    \n",
    "    # 2. Pulizia campo Gender\n",
    "    if 'Gender' in df.columns:\n",
    "        df['Gender'] = df['Gender'].str.strip()  # Rimuove spazi\n",
    "        df['Gender'] = df['Gender'].replace({'M ': 'M'})  # Corregge spazi extra\n",
    "        df['Gender'] = df['Gender'].map({'M': 'Maschio', 'F': 'Femmina'})\n",
    "    \n",
    "    # 3. Calcolo et√† e anzianit√† (al 18 luglio 2025)\n",
    "    oggi = pd.Timestamp('2025-07-18')\n",
    "    df['Eta'] = (oggi - df['DateOfBirth']).dt.days // 365\n",
    "    df['AnniServizio'] = (oggi - df['HiringDate']).dt.days // 365\n",
    "    df['AnnoAssunzione'] = df['HiringDate'].dt.year\n",
    "    \n",
    "    # 4. Rimozione colonne satisfaction (non disponibili)\n",
    "    colonne_da_rimuovere = ['EmployeeSatisfaction', 'EngagementSurvey']\n",
    "    df = df.drop(columns=[col for col in colonne_da_rimuovere if col in df.columns], errors='ignore')\n",
    "    \n",
    "    # 5. Pulizia salari (rimuove valori negativi o irrealistici)\n",
    "    df = df[df['Salary'] > 0]\n",
    "    df = df[df['Salary'] < 500000]  # Rimuove salari irrealistici\n",
    "    \n",
    "    print(f\"‚úÖ Pulizia completata!\")\n",
    "    print(f\"üìä Dati finali: {len(df):,} dipendenti\")\n",
    "    print(f\"üìÖ Periodo analizzato: {df['AnnoAssunzione'].min()} - {df['AnnoAssunzione'].max()}\")\n",
    "    \n",
    "    return df\n",
    "\n",
    "# Pulisci i dati\n",
    "df = pulisci_dati_hr(df_raw)\n",
    "\n",
    "# Mostra un'anteprima dei dati puliti\n",
    "print(\"\\nüìã Anteprima dati (prime 5 righe):\")\n",
    "print(df[['EmployeeName', 'Department', 'Salary', 'Eta', 'AnniServizio', 'EmploymentStatus']].head())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üìä Panoramica Generale dell'Azienda\n",
    "\n",
    "Prima di approfondire le analisi, vediamo i **numeri chiave** della nostra organizzazione. Questi dati ti danno una fotografia immediata dello stato dell'azienda.\n",
    "\n",
    "**üíº Cosa guardare:**\n",
    "- **Dipendenti attivi vs ex-dipendenti** ‚Üí Tasso di retention\n",
    "- **Et√† media** ‚Üí Pianificazione successioni\n",
    "- **Anzianit√† media** ‚Üí Stabilit√† workforce\n",
    "- **Distribuzione dipartimenti** ‚Üí Bilanciamento organizzativo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calcolo statistiche generali\n",
    "totale_dipendenti = len(df)\n",
    "dipendenti_attivi = len(df[df['EmploymentStatus'] == 'Active'])\n",
    "ex_dipendenti = totale_dipendenti - dipendenti_attivi\n",
    "tasso_retention = (dipendenti_attivi / totale_dipendenti) * 100\n",
    "\n",
    "eta_media = df['Eta'].mean()\n",
    "anzianita_media = df['AnniServizio'].mean()\n",
    "salario_medio = df['Salary'].mean()\n",
    "num_dipartimenti = df['Department'].nunique()\n",
    "\n",
    "print(\"üè¢ PANORAMICA AZIENDALE\")\n",
    "print(\"=\" * 50)\n",
    "print(f\"üë• Totale dipendenti (presente + passato): {totale_dipendenti:,}\")\n",
    "print(f\"‚úÖ Dipendenti attualmente attivi: {dipendenti_attivi:,}\")\n",
    "print(f\"‚ùå Ex-dipendenti: {ex_dipendenti:,}\")\n",
    "print(f\"üìà Tasso di retention: {tasso_retention:.1f}%\")\n",
    "print()\n",
    "print(f\"üë§ Et√† media dipendenti: {eta_media:.1f} anni\")\n",
    "print(f\"‚è∞ Anzianit√† media: {anzianita_media:.1f} anni\")\n",
    "print(f\"üí∞ Salario medio: ‚Ç¨{salario_medio:,.0f}\")\n",
    "print(f\"üè¨ Numero dipartimenti: {num_dipartimenti}\")\n",
    "\n",
    "print(\"\\nüéØ PRIME OSSERVAZIONI:\")\n",
    "if tasso_retention >= 80:\n",
    "    print(\"‚úÖ Ottimo tasso di retention - i dipendenti tendono a rimanere\")\n",
    "elif tasso_retention >= 70:\n",
    "    print(\"‚ö†Ô∏è Tasso di retention nella media - monitorare le uscite\")\n",
    "else:\n",
    "    print(\"üö® Tasso di retention basso - problemi di turnover da affrontare\")\n",
    "\n",
    "if eta_media > 45:\n",
    "    print(\"üë¥ Workforce relativamente matura - pianificare ricambio generazionale\")\n",
    "elif eta_media < 35:\n",
    "    print(\"üë∂ Workforce giovane - investire in sviluppo e crescita\")\n",
    "else:\n",
    "    print(\"üë• Et√† bilanciata - buon mix generazionale\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üë• Analisi Demografica Dettagliata\n",
    "\n",
    "**Perch√© √® importante per l'HR:**\n",
    "- Capire la composizione del nostro team\n",
    "- Identificare squilibri (di genere, et√†, dipartimenti)\n",
    "- Pianificare politiche di diversity & inclusion\n",
    "- Preparare strategie di recruitment\n",
    "\n",
    "I grafici sotto mostrano **chi sono** i nostri dipendenti."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Creazione dashboard demografico\n",
    "fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n",
    "fig.suptitle('üë• DASHBOARD DEMOGRAFICO', fontsize=16, fontweight='bold')\n",
    "\n",
    "# 1. Distribuzione per genere\n",
    "if 'Gender' in df.columns:\n",
    "    genere_counts = df['Gender'].value_counts()\n",
    "    axes[0,0].pie(genere_counts.values, labels=genere_counts.index, autopct='%1.1f%%', \n",
    "                  startangle=90, colors=['lightblue', 'lightpink'])\n",
    "    axes[0,0].set_title('Distribuzione per Genere')\n",
    "else:\n",
    "    axes[0,0].text(0.5, 0.5, 'Dati genere\\nnon disponibili', \n",
    "                   ha='center', va='center', transform=axes[0,0].transAxes)\n",
    "    axes[0,0].set_title('Distribuzione per Genere')\n",
    "\n",
    "# 2. Dipendenti per dipartimento\n",
    "dept_counts = df['Department'].value_counts()\n",
    "colors = plt.cm.Set3(np.linspace(0, 1, len(dept_counts)))\n",
    "bars = axes[0,1].barh(dept_counts.index, dept_counts.values, color=colors)\n",
    "axes[0,1].set_title('Dipendenti per Dipartimento')\n",
    "axes[0,1].set_xlabel('Numero Dipendenti')\n",
    "\n",
    "# Aggiungi valori sulle barre\n",
    "for i, bar in enumerate(bars):\n",
    "    width = bar.get_width()\n",
    "    axes[0,1].text(width + 1, bar.get_y() + bar.get_height()/2, \n",
    "                   f'{int(width)}', ha='left', va='center')\n",
    "\n",
    "# 3. Distribuzione et√†\n",
    "ages = df['Eta'].dropna()\n",
    "axes[1,0].hist(ages, bins=15, color='skyblue', alpha=0.7, edgecolor='navy')\n",
    "axes[1,0].axvline(ages.mean(), color='red', linestyle='--', linewidth=2, \n",
    "                  label=f'Et√† media: {ages.mean():.1f} anni')\n",
    "axes[1,0].set_title('Distribuzione Et√† Dipendenti')\n",
    "axes[1,0].set_xlabel('Et√† (anni)')\n",
    "axes[1,0].set_ylabel('Numero Dipendenti')\n",
    "axes[1,0].legend()\n",
    "axes[1,0].grid(axis='y', alpha=0.3)\n",
    "\n",
    "# 4. Distribuzione anzianit√†\n",
    "tenure = df['AnniServizio'].dropna()\n",
    "axes[1,1].hist(tenure, bins=15, color='lightgreen', alpha=0.7, edgecolor='darkgreen')\n",
    "axes[1,1].axvline(tenure.mean(), color='red', linestyle='--', linewidth=2, \n",
    "                  label=f'Anzianit√† media: {tenure.mean():.1f} anni')\n",
    "axes[1,1].set_title('Distribuzione Anzianit√† di Servizio')\n",
    "axes[1,1].set_xlabel('Anni di Servizio')\n",
    "axes[1,1].set_ylabel('Numero Dipendenti')\n",
    "axes[1,1].legend()\n",
    "axes[1,1].grid(axis='y', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Insights demografici\n",
    "print(\"\\nüîç INSIGHTS DEMOGRAFICI:\")\n",
    "print(\"=\" * 40)\n",
    "\n",
    "# Analisi genere\n",
    "if 'Gender' in df.columns:\n",
    "    gender_pct = df['Gender'].value_counts(normalize=True) * 100\n",
    "    print(f\"üë´ Bilanciamento di genere:\")\n",
    "    for gender, pct in gender_pct.items():\n",
    "        print(f\"   ‚Ä¢ {gender}: {pct:.1f}%\")\n",
    "\n",
    "# Dipartimento pi√π grande\n",
    "dept_piu_grande = dept_counts.index[0]\n",
    "print(f\"üè¢ Dipartimento pi√π grande: {dept_piu_grande} ({dept_counts.iloc[0]} dipendenti)\")\n",
    "\n",
    "# Fasce et√†\n",
    "giovani = len(df[df['Eta'] < 30])\n",
    "medi = len(df[(df['Eta'] >= 30) & (df['Eta'] < 50)])\n",
    "senior = len(df[df['Eta'] >= 50])\n",
    "print(f\"üë• Fasce di et√†:\")\n",
    "print(f\"   ‚Ä¢ Under 30: {giovani} ({giovani/len(df)*100:.1f}%)\")\n",
    "print(f\"   ‚Ä¢ 30-50 anni: {medi} ({medi/len(df)*100:.1f}%)\")\n",
    "print(f\"   ‚Ä¢ Over 50: {senior} ({senior/len(df)*100:.1f}%)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üí∞ Analisi delle Retribuzioni\n",
    "\n",
    "**Cosa ci dice l'analisi salariale:**\n",
    "- **Equit√† retributiva** tra dipartimenti e generi\n",
    "- **Competitivit√†** delle nostre offerte\n",
    "- **Outliers** che potrebbero indicare problemi o talenti speciali\n",
    "- **Budget planning** per aumenti e nuove assunzioni\n",
    "\n",
    "**üéØ Focus per l'HR:** Cerca disparit√† che potrebbero creare problemi di retention o equity."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Dashboard analisi salariale\n",
    "fig, axes = plt.subplots(2, 2, figsize=(16, 12))\n",
    "fig.suptitle('üí∞ ANALISI RETRIBUZIONI', fontsize=16, fontweight='bold')\n",
    "\n",
    "# 1. Distribuzione generale salari\n",
    "salari = df['Salary']\n",
    "axes[0,0].hist(salari, bins=25, color='gold', alpha=0.7, edgecolor='orange')\n",
    "axes[0,0].axvline(salari.mean(), color='red', linestyle='--', linewidth=2, \n",
    "                  label=f'Media: ‚Ç¨{salari.mean():,.0f}')\n",
    "axes[0,0].axvline(salari.median(), color='blue', linestyle='--', linewidth=2, \n",
    "                  label=f'Mediana: ‚Ç¨{salari.median():,.0f}')\n",
    "axes[0,0].set_title('Distribuzione Salari')\n",
    "axes[0,0].set_xlabel('Salario Annuo (‚Ç¨)')\n",
    "axes[0,0].set_ylabel('Numero Dipendenti')\n",
    "axes[0,0].legend()\n",
    "axes[0,0].grid(axis='y', alpha=0.3)\n",
    "\n",
    "# 2. Salari per dipartimento (boxplot)\n",
    "df_sorted_dept = df.sort_values('Salary', ascending=False)\n",
    "sns.boxplot(data=df, y='Department', x='Salary', ax=axes[0,1], palette='Set2')\n",
    "axes[0,1].set_title('Distribuzione Salari per Dipartimento')\n",
    "axes[0,1].set_xlabel('Salario Annuo (‚Ç¨)')\n",
    "\n",
    "# 3. Salario medio per dipartimento\n",
    "salario_per_dept = df.groupby('Department')['Salary'].mean().sort_values(ascending=True)\n",
    "colors = plt.cm.viridis(np.linspace(0, 1, len(salario_per_dept)))\n",
    "bars = axes[1,0].barh(salario_per_dept.index, salario_per_dept.values, color=colors)\n",
    "axes[1,0].set_title('Salario Medio per Dipartimento')\n",
    "axes[1,0].set_xlabel('Salario Medio (‚Ç¨)')\n",
    "\n",
    "# Aggiungi valori\n",
    "for i, bar in enumerate(bars):\n",
    "    width = bar.get_width()\n",
    "    axes[1,0].text(width + 500, bar.get_y() + bar.get_height()/2, \n",
    "                   f'‚Ç¨{int(width):,}', ha='left', va='center')\n",
    "\n",
    "# 4. Salario vs Et√† (scatter plot)\n",
    "scatter = axes[1,1].scatter(df['Eta'], df['Salary'], c=df['AnniServizio'], \n",
    "                           cmap='viridis', alpha=0.6, s=50)\n",
    "axes[1,1].set_title('Salario vs Et√† (colore = anni servizio)')\n",
    "axes[1,1].set_xlabel('Et√† (anni)')\n",
    "axes[1,1].set_ylabel('Salario (‚Ç¨)')\n",
    "plt.colorbar(scatter, ax=axes[1,1], label='Anni di Servizio')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Statistiche salariali dettagliate\n",
    "print(\"\\nüìä STATISTICHE SALARIALI DETTAGLIATE:\")\n",
    "print(\"=\" * 45)\n",
    "\n",
    "print(f\"üí∞ Salario medio aziendale: ‚Ç¨{salari.mean():,.0f}\")\n",
    "print(f\"üìä Salario mediano: ‚Ç¨{salari.median():,.0f}\")\n",
    "print(f\"üìà Salario massimo: ‚Ç¨{salari.max():,.0f}\")\n",
    "print(f\"üìâ Salario minimo: ‚Ç¨{salari.min():,.0f}\")\n",
    "print(f\"üìè Range salariale: ‚Ç¨{salari.max() - salari.min():,.0f}\")\n",
    "\n",
    "print(\"\\nüèÜ TOP 3 DIPARTIMENTI PER SALARIO MEDIO:\")\n",
    "top_salari = salario_per_dept.sort_values(ascending=False).head(3)\n",
    "for i, (dept, salario) in enumerate(top_salari.items(), 1):\n",
    "    print(f\"   {i}. {dept}: ‚Ç¨{salario:,.0f}\")\n",
    "\n",
    "# Analisi disparit√† salariali\n",
    "if 'Gender' in df.columns:\n",
    "    print(\"\\nüë´ ANALISI EQUIT√Ä DI GENERE:\")\n",
    "    gender_salary = df.groupby('Gender')['Salary'].agg(['mean', 'median', 'count'])\n",
    "    print(gender_salary.round(0))\n",
    "    \n",
    "    if len(gender_salary) >= 2:\n",
    "        gap = gender_salary['mean'].max() - gender_salary['mean'].min()\n",
    "        gap_pct = (gap / gender_salary['mean'].min()) * 100\n",
    "        print(f\"\\nüìä Gap salariale di genere: ‚Ç¨{gap:,.0f} ({gap_pct:.1f}%)\")\n",
    "        \n",
    "        if gap_pct > 10:\n",
    "            print(\"üö® ALERT: Gap salariale significativo - da investigare\")\n",
    "        elif gap_pct > 5:\n",
    "            print(\"‚ö†Ô∏è Gap salariale moderato - monitorare\")\n",
    "        else:\n",
    "            print(\"‚úÖ Gap salariale contenuto\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ‚≠ê Analisi delle Performance\n",
    "\n",
    "**Perch√© analizzare le performance:**\n",
    "- Identificare **top performers** e **dipendenti a rischio**\n",
    "- Verificare se ci sono pattern nei dipartimenti\n",
    "- Collegare performance a retention e salari\n",
    "- Pianificare **programmi di sviluppo** mirati\n",
    "\n",
    "**üéØ Per l'HR:** Usa questi dati per decisioni su promozioni, formazione e gestione dei talenti."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Dashboard performance\n",
    "fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n",
    "fig.suptitle('‚≠ê ANALISI PERFORMANCE', fontsize=16, fontweight='bold')\n",
    "\n",
    "# 1. Distribuzione performance score\n",
    "perf_counts = df['PerformanceScore'].value_counts()\n",
    "colors = ['green', 'lightgreen', 'orange', 'red']\n",
    "colors = colors[:len(perf_counts)]  # Usa solo i colori necessari\n",
    "\n",
    "bars = axes[0,0].bar(perf_counts.index, perf_counts.values, color=colors, alpha=0.7)\n",
    "axes[0,0].set_title('Distribuzione Performance Score')\n",
    "axes[0,0].set_ylabel('Numero Dipendenti')\n",
    "axes[0,0].tick_params(axis='x', rotation=45)\n",
    "\n",
    "# Aggiungi percentuali\n",
    "total = perf_counts.sum()\n",
    "for bar, count in zip(bars, perf_counts.values):\n",
    "    height = bar.get_height()\n",
    "    axes[0,0].text(bar.get_x() + bar.get_width()/2., height + 1,\n",
    "                   f'{count}\\n({count/total*100:.1f}%)', \n",
    "                   ha='center', va='bottom')\n",
    "\n",
    "# 2. Performance per dipartimento (percentuale)\n",
    "perf_dept = pd.crosstab(df['Department'], df['PerformanceScore'], normalize='index') * 100\n",
    "perf_dept.plot(kind='bar', stacked=True, ax=axes[0,1], \n",
    "               colormap='RdYlGn', rot=45)\n",
    "axes[0,1].set_title('Performance per Dipartimento (%)')\n",
    "axes[0,1].set_ylabel('Percentuale')\n",
    "axes[0,1].legend(title='Performance', bbox_to_anchor=(1.05, 1), loc='upper left')\n",
    "\n",
    "# 3. Performance vs Salario\n",
    "sns.boxplot(data=df, x='PerformanceScore', y='Salary', ax=axes[1,0], palette='viridis')\n",
    "axes[1,0].set_title('Salario per Livello di Performance')\n",
    "axes[1,0].tick_params(axis='x', rotation=45)\n",
    "axes[1,0].set_ylabel('Salario (‚Ç¨)')\n",
    "\n",
    "# 4. Performance vs Tenure\n",
    "sns.boxplot(data=df, x='PerformanceScore', y='AnniServizio', ax=axes[1,1], palette='plasma')\n",
    "axes[1,1].set_title('Anzianit√† per Livello di Performance')\n",
    "axes[1,1].tick_params(axis='x', rotation=45)\n",
    "axes[1,1].set_ylabel('Anni di Servizio')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Analisi performance dettagliata\n",
    "print(\"\\nüéØ ANALISI PERFORMANCE DETTAGLIATA:\")\n",
    "print(\"=\" * 40)\n",
    "\n",
    "# Statistiche generali\n",
    "total_dipendenti = len(df)\n",
    "performance_stats = df['PerformanceScore'].value_counts()\n",
    "print(\"üìä Distribuzione Performance:\")\n",
    "for score, count in performance_stats.items():\n",
    "    pct = (count / total_dipendenti) * 100\n",
    "    print(f\"   ‚Ä¢ {score}: {count} dipendenti ({pct:.1f}%)\")\n",
    "\n",
    "# Top e bottom performers\n",
    "if 'Eccellente' in performance_stats.index:\n",
    "    top_performers = performance_stats['Eccellente']\n",
    "    print(f\"\\nüèÜ Top Performers (Eccellente): {top_performers} ({top_performers/total_dipendenti*100:.1f}%)\")\n",
    "\n",
    "if 'Insufficiente' in performance_stats.index:\n",
    "    low_performers = performance_stats['Insufficiente']\n",
    "    print(f\"‚ö†Ô∏è Performance Insufficiente: {low_performers} ({low_performers/total_dipendenti*100:.1f}%)\")\n",
    "    if low_performers > 0:\n",
    "        print(\"   ‚Üí Consiglio: Implementare piani di miglioramento\")\n",
    "\n",
    "# Correlazione performance-salario\n",
    "print(\"\\nüí∞ CORRELAZIONE PERFORMANCE-SALARIO:\")\n",
    "perf_salary = df.groupby('PerformanceScore')['Salary'].mean().sort_values(ascending=False)\n",
    "for score, avg_salary in perf_salary.items():\n",
    "    print(f\"   ‚Ä¢ {score}: ‚Ç¨{avg_salary:,.0f} (media)\")\n",
    "\n",
    "# Alert per problemi potenziali\n",
    "print(\"\\nüö® ALERT E RACCOMANDAZIONI:\")\n",
    "if 'Insufficiente' in performance_stats.index and performance_stats['Insufficiente'] > total_dipendenti * 0.05:\n",
    "    print(\"‚ùó Alto numero di performance insufficienti (>5%)\")\n",
    "    print(\"   ‚Üí Azione: Review processi di hiring e training\")\n",
    "\n",
    "if 'Eccellente' in performance_stats.index and performance_stats['Eccellente'] < total_dipendenti * 0.10:\n",
    "    print(\"‚ùó Pochi top performers (<10%)\")\n",
    "    print(\"   ‚Üí Azione: Programmi di sviluppo talenti\")\n",
    "\n",
    "print(\"‚úÖ Monitorare regolarmente questi KPI per identificare trend\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üîÑ Analisi Turnover e Retention\n",
    "\n",
    "**Il turnover √® uno dei KPI pi√π critici per l'HR:**\n",
    "- **Costi diretti:** Recruitment, training, onboarding\n",
    "- **Costi indiretti:** Perdita di conoscenza, morale del team\n",
    "- **Indicatore di salute** organizzativa\n",
    "\n",
    "**üéØ Obiettivo:** Identificare pattern di turnover per azioni preventive."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Funzioni per calcolo turnover\n",
    "def calcola_turnover_annuale(df, anno):\n",
    "    \"\"\"\n",
    "    Calcola il tasso di turnover per un anno specifico\n",
    "    \n",
    "    Formula: (Dipendenti usciti nell'anno / Media dipendenti nell'anno) * 100\n",
    "    \"\"\"\n",
    "    inizio_anno = pd.Timestamp(f\"{anno}-01-01\")\n",
    "    fine_anno = pd.Timestamp(f\"{anno}-12-31\")\n",
    "    \n",
    "    # Dipendenti che hanno lasciato durante l'anno\n",
    "    usciti = df['TerminationDate'].between(inizio_anno, fine_anno, na=False).sum()\n",
    "    \n",
    "    # Calcola headcount medio\n",
    "    hc_inizio = ((df['HiringDate'] <= inizio_anno) & \n",
    "                ((df['TerminationDate'].isna()) | (df['TerminationDate'] >= inizio_anno))).sum()\n",
    "    hc_fine = ((df['HiringDate'] <= fine_anno) & \n",
    "              ((df['TerminationDate'].isna()) | (df['TerminationDate'] >= fine_anno))).sum()\n",
    "    \n",
    "    hc_medio = (hc_inizio + hc_fine) / 2\n",
    "    \n",
    "    return (usciti / hc_medio * 100) if hc_medio > 0 else 0\n",
    "\n",
    "# Dashboard turnover\n",
    "fig, axes = plt.subplots(2, 2, figsize=(16, 12))\n",
    "fig.suptitle('üîÑ ANALISI TURNOVER E RETENTION', fontsize=16, fontweight='bold')\n",
    "\n",
    "# 1. Status occupazionale attuale\n",
    "status_counts = df['EmploymentStatus'].value_counts()\n",
    "colors = ['green', 'orange', 'red']\n",
    "colors = colors[:len(status_counts)]\n",
    "\n",
    "wedges, texts, autotexts = axes[0,0].pie(status_counts.values, labels=status_counts.index, \n",
    "                                         autopct='%1.1f%%', startangle=90, colors=colors)\n",
    "axes[0,0].set_title('Status Occupazionale Attuale')\n",
    "\n",
    "# 2. Turnover per dipartimento\n",
    "turnover_dept = df.groupby('Department')['EmploymentStatus'].apply(\n",
    "    lambda x: (x != 'Active').sum() / len(x) * 100\n",
    ").sort_values(ascending=True)\n",
    "\n",
    "colors_dept = plt.cm.Reds(np.linspace(0.3, 0.9, len(turnover_dept)))\n",
    "bars = axes[0,1].barh(turnover_dept.index, turnover_dept.values, color=colors_dept)\n",
    "axes[0,1].set_title('Tasso Turnover per Dipartimento (%)')\n",
    "axes[0,1].set_xlabel('Turnover Rate (%)')\n",
    "\n",
    "# Aggiungi valori\n",
    "for bar, value in zip(bars, turnover_dept.values):\n",
    "    axes[0,1].text(bar.get_width() + 0.5, bar.get_y() + bar.get_height()/2, \n",
    "                   f'{value:.1f}%', ha='left', va='center')\n",
    "\n",
    "# 3. Trend assunzioni per anno\n",
    "assunzioni_anno = df.groupby('AnnoAssunzione').size()\n",
    "axes[1,0].plot(assunzioni_anno.index, assunzioni_anno.values, \n",
    "               marker='o', linewidth=3, markersize=8, color='blue')\n",
    "axes[1,0].set_title('Trend Assunzioni per Anno')\n",
    "axes[1,0].set_xlabel('Anno')\n",
    "axes[1,0].set_ylabel('Numero Assunzioni')\n",
    "axes[1,0].grid(True, alpha=0.3)\n",
    "\n",
    "# Aggiungi valori sui punti\n",
    "for x, y in zip(assunzioni_anno.index, assunzioni_anno.values):\n",
    "    axes[1,0].annotate(f'{y}', (x, y), textcoords=\"offset points\", \n",
    "                       xytext=(0,10), ha='center')\n",
    "\n",
    "# 4. Tenure distribution per status\n",
    "active_tenure = df[df['EmploymentStatus'] == 'Active']['AnniServizio']\n",
    "terminated_tenure = df[df['EmploymentStatus'] != 'Active']['AnniServizio']\n",
    "\n",
    "axes[1,1].hist([active_tenure, terminated_tenure], bins=12, alpha=0.7, \n",
    "               label=['Attivi', 'Ex-dipendenti'], color=['green', 'red'])\n",
    "axes[1,1].set_title('Distribuzione Anzianit√† per Status')\n",
    "axes[1,1].set_xlabel('Anni di Servizio')\n",
    "axes[1,1].set_ylabel('Numero Dipendenti')\n",
    "axes[1,1].legend()\n",
    "axes[1,1].grid(axis='y', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Calcolo turnover annuale\n",
    "print(\"\\nüìä ANALISI TURNOVER DETTAGLIATA:\")\n",
    "print(\"=\" * 40)\n",
    "\n",
    "# Turnover rate attuale\n",
    "dipendenti_totali = len(df)\n",
    "dipendenti_attivi = len(df[df['EmploymentStatus'] == 'Active'])\n",
    "ex_dipendenti = dipendenti_totali - dipendenti_attivi\n",
    "turnover_totale = (ex_dipendenti / dipendenti_totali) * 100\n",
    "\n",
    "print(f\"üîÑ Turnover Rate Complessivo: {turnover_totale:.1f}%\")\n",
    "print(f\"   ‚Ä¢ Dipendenti attuali: {dipendenti_attivi:,}\")\n",
    "print(f\"   ‚Ä¢ Ex-dipendenti: {ex_dipendenti:,}\")\n",
    "\n",
    "# Turnover per anno (ultimi anni)\n",
    "print(\"\\nüìÖ TURNOVER ANNUALE:\")\n",
    "anni_analisi = range(2020, 2025)\n",
    "for anno in anni_analisi:\n",
    "    turnover_anno = calcola_turnover_annuale(df, anno)\n",
    "    print(f\"   ‚Ä¢ {anno}: {turnover_anno:.1f}%\")\n",
    "\n",
    "# Top dipartimenti per turnover\n",
    "print(\"\\nüè¢ DIPARTIMENTI CON TURNOVER PI√ô ALTO:\")\n",
    "top_turnover = turnover_dept.sort_values(ascending=False).head(3)\n",
    "for i, (dept, rate) in enumerate(top_turnover.items(), 1):\n",
    "    print(f\"   {i}. {dept}: {rate:.1f}%\")\n",
    "\n",
    "# Analisi tenure degli ex-dipendenti\n",
    "if len(terminated_tenure) > 0:\n",
    "    print(f\"\\n‚è∞ ANALISI EX-DIPENDENTI:\")\n",
    "    print(f\"   ‚Ä¢ Anzianit√† media al momento dell'uscita: {terminated_tenure.mean():.1f} anni\")\n",
    "    print(f\"   ‚Ä¢ Anzianit√† mediana: {terminated_tenure.median():.1f} anni\")\n",
    "    \n",
    "    # Pattern di uscita\n",
    "    early_leavers = (terminated_tenure <= 2).sum()\n",
    "    mid_leavers = ((terminated_tenure > 2) & (terminated_tenure <= 5)).sum()\n",
    "    late_leavers = (terminated_tenure > 5).sum()\n",
    "    \n",
    "    print(f\"   ‚Ä¢ Uscite precoci (‚â§2 anni): {early_leavers} ({early_leavers/len(terminated_tenure)*100:.1f}%)\")\n",
    "    print(f\"   ‚Ä¢ Uscite medie (2-5 anni): {mid_leavers} ({mid_leavers/len(terminated_tenure)*100:.1f}%)\")\n",
    "    print(f\"   ‚Ä¢ Uscite tardive (>5 anni): {late_leavers} ({late_leavers/len(terminated_tenure)*100:.1f}%)\")\n",
    "\n",
    "# Raccomandazioni\n",
    "print(\"\\nüí° RACCOMANDAZIONI:\")\n",
    "if turnover_totale > 20:\n",
    "    print(\"üö® Turnover critico (>20%) - Azione immediata necessaria\")\n",
    "    print(\"   ‚Üí Focus su employee engagement e retention\")\n",
    "elif turnover_totale > 15:\n",
    "    print(\"‚ö†Ô∏è Turnover alto (>15%) - Monitorare attentamente\")\n",
    "    print(\"   ‚Üí Analizzare cause di uscita\")\n",
    "else:\n",
    "    print(\"‚úÖ Turnover nella norma (<15%)\")\n",
    "\n",
    "if early_leavers > len(terminated_tenure) * 0.4:\n",
    "    print(\"‚ùó Molte uscite precoci - Rivedere onboarding e selezione\")\n",
    "\n",
    "if len(top_turnover) > 0 and top_turnover.iloc[0] > 30:\n",
    "    print(f\"‚ùó Dipartimento {top_turnover.index[0]} ha turnover critico - Investigare cause\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üë¥ Previsione Pensionamenti\n",
    "\n",
    "**Perch√© √® cruciale per l'HR:**\n",
    "- **Succession Planning** - Preparare i ricambi per posizioni chiave\n",
    "- **Knowledge Transfer** - Non perdere competenze critiche\n",
    "- **Budget Planning** - Costi di recruitment e training\n",
    "- **Workforce Planning** - Mantenere continuit√† operativa\n",
    "\n",
    "**üéØ Focus:** Identifica quando avremo \"ondate\" di pensionamenti."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calcola_pensionamenti_futuri(df, anni_previsione=10, eta_pensione=67):\n",
    "    \"\"\"\n",
    "    Calcola i pensionamenti previsti per i prossimi anni\n",
    "    \n",
    "    Args:\n",
    "    - df: DataFrame con i dati\n",
    "    - anni_previsione: Quanti anni guardare avanti\n",
    "    - eta_pensione: Et√† di pensionamento (default 67)\n",
    "    \"\"\"\n",
    "    previsioni = []\n",
    "    anno_base = 2025\n",
    "    \n",
    "    # Solo dipendenti attivi\n",
    "    attivi = df[df['EmploymentStatus'] == 'Active'].copy()\n",
    "    \n",
    "    for offset in range(anni_previsione):\n",
    "        anno = anno_base + offset\n",
    "        fine_anno = pd.Timestamp(f\"{anno}-12-31\")\n",
    "        \n",
    "        # Calcola et√† a fine anno\n",
    "        eta_fine_anno = (fine_anno - attivi['DateOfBirth']).dt.days // 365\n",
    "        \n",
    "        # Conta quanti raggiungono l'et√† pensionabile\n",
    "        pensionabili = (eta_fine_anno >= eta_pensione).sum()\n",
    "        \n",
    "        previsioni.append({\n",
    "            'Anno': anno,\n",
    "            'Pensionamenti_Previsti': pensionabili\n",
    "        })\n",
    "    \n",
    "    return pd.DataFrame(previsioni)\n",
    "\n",
    "# Calcola previsioni pensionamenti\n",
    "previsioni_pensioni = calcola_pensionamenti_futuri(df)\n",
    "\n",
    "# Dashboard pensionamenti\n",
    "fig, axes = plt.subplots(1, 2, figsize=(16, 6))\n",
    "fig.suptitle('üë¥ PREVISIONI PENSIONAMENTI', fontsize=16, fontweight='bold')\n",
    "\n",
    "# 1. Grafico pensionamenti futuri\n",
    "bars = axes[0].bar(previsioni_pensioni['Anno'], previsioni_pensioni['Pensionamenti_Previsti'], \n",
    "                   color='lightcoral', alpha=0.8, edgecolor='darkred')\n",
    "axes[0].set_title('Pensionamenti Previsti per Anno')\n",
    "axes[0].set_xlabel('Anno')\n",
    "axes[0].set_ylabel('Numero Pensionamenti')\n",
    "axes[0].grid(axis='y', alpha=0.3)\n",
    "\n",
    "# Aggiungi valori sulle barre\n",
    "for bar in bars:\n",
    "    height = bar.get_height()\n",
    "    if height > 0:\n",
    "        axes[0].text(bar.get_x() + bar.get_width()/2., height + 0.1,\n",
    "                     f'{int(height)}', ha='center', va='bottom', fontweight='bold')\n",
    "\n",
    "# 2. Distribuzione et√† attuale con soglia pensione\n",
    "dipendenti_attivi = df[df['EmploymentStatus'] == 'Active']\n",
    "eta_attivi = dipendenti_attivi['Eta'].dropna()\n",
    "\n",
    "axes[1].hist(eta_attivi, bins=20, alpha=0.7, color='skyblue', edgecolor='navy')\n",
    "axes[1].axvline(x=67, color='red', linestyle='--', linewidth=3, \n",
    "                label='Et√† Pensionamento (67 anni)')\n",
    "axes[1].axvline(x=eta_attivi.mean(), color='orange', linestyle='--', linewidth=2, \n",
    "                label=f'Et√† Media ({eta_attivi.mean():.1f} anni)')\n",
    "axes[1].set_title('Distribuzione Et√† Dipendenti Attivi')\n",
    "axes[1].set_xlabel('Et√† (anni)')\n",
    "axes[1].set_ylabel('Numero Dipendenti')\n",
    "axes[1].legend()\n",
    "axes[1].grid(axis='y', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Analisi dettagliata pensionamenti\n",
    "print(\"\\nüë¥ ANALISI PENSIONAMENTI DETTAGLIATA:\")\n",
    "print(\"=\" * 45)\n",
    "\n",
    "# Situazione attuale\n",
    "gia_pensionabili = len(dipendenti_attivi[dipendenti_attivi['Eta'] >= 67])\n",
    "prossimi_5_anni = len(dipendenti_attivi[(dipendenti_attivi['Eta'] >= 62) & (dipendenti_attivi['Eta'] < 67)])\n",
    "eta_media_attivi = eta_attivi.mean()\n",
    "\n",
    "print(f\"üë• Dipendenti attivi totali: {len(dipendenti_attivi):,}\")\n",
    "print(f\"üéØ Gi√† in et√† pensionabile (‚â•67 anni): {gia_pensionabili}\")\n",
    "print(f\"‚è∞ Prossimi alla pensione (62-66 anni): {prossimi_5_anni}\")\n",
    "print(f\"üìä Et√† media dipendenti attivi: {eta_media_attivi:.1f} anni\")\n",
    "\n",
    "print(\"\\nüìÖ PREVISIONI PENSIONAMENTI PER ANNO:\")\n",
    "pensionamenti_totali = 0\n",
    "for _, row in previsioni_pensioni.iterrows():\n",
    "    anno = int(row['Anno'])\n",
    "    pensionamenti = int(row['Pensionamenti_Previsti'])\n",
    "    pensionamenti_totali += pensionamenti\n",
    "    pct_workforce = (pensionamenti / len(dipendenti_attivi)) * 100\n",
    "    print(f\"   ‚Ä¢ {anno}: {pensionamenti} pensionamenti ({pct_workforce:.1f}% workforce)\")\n",
    "\n",
    "print(f\"\\nüìä Totale pensionamenti previsti (10 anni): {pensionamenti_totali}\")\n",
    "print(f\"üìà % workforce che andr√† in pensione: {(pensionamenti_totali/len(dipendenti_attivi)*100):.1f}%\")\n",
    "\n",
    "# Pensionamenti per dipartimento\n",
    "print(\"\\nüè¢ PENSIONAMENTI PER DIPARTIMENTO (prossimi 5 anni):\")\n",
    "prossimi_pensionandi = dipendenti_attivi[dipendenti_attivi['Eta'] >= 62]\n",
    "pensioni_per_dept = prossimi_pensionandi.groupby('Department').size().sort_values(ascending=False)\n",
    "\n",
    "for dept, count in pensioni_per_dept.items():\n",
    "    total_dept = len(dipendenti_attivi[dipendenti_attivi['Department'] == dept])\n",
    "    pct = (count / total_dept) * 100\n",
    "    print(f\"   ‚Ä¢ {dept}: {count} pensionamenti ({pct:.1f}% del dipartimento)\")\n",
    "\n",
    "# Alert e raccomandazioni\n",
    "print(\"\\nüö® ALERT E RACCOMANDAZIONI:\")\n",
    "\n",
    "if gia_pensionabili > 0:\n",
    "    print(f\"‚ùó {gia_pensionabili} dipendenti gi√† in et√† pensionabile - Verificare piani di uscita\")\n",
    "\n",
    "if prossimi_5_anni > len(dipendenti_attivi) * 0.15:\n",
    "    print(\"üö® CRITICO: >15% dei dipendenti prossimi alla pensione\")\n",
    "    print(\"   ‚Üí Priorit√† assoluta: Succession planning e knowledge transfer\")\n",
    "elif prossimi_5_anni > len(dipendenti_attivi) * 0.10:\n",
    "    print(\"‚ö†Ô∏è ATTENZIONE: >10% dei dipendenti prossimi alla pensione\")\n",
    "    print(\"   ‚Üí Iniziare pianificazione successioni\")\n",
    "\n",
    "# Identifica il \"picco\" di pensionamenti\n",
    "anno_picco = previsioni_pensioni.loc[previsioni_pensioni['Pensionamenti_Previsti'].idxmax(), 'Anno']\n",
    "picco_pensionamenti = previsioni_pensioni['Pensionamenti_Previsti'].max()\n",
    "\n",
    "if picco_pensionamenti > 0:\n",
    "    print(f\"\\nüìà PICCO PENSIONAMENTI: {int(anno_picco)} ({int(picco_pensionamenti)} dipendenti)\")\n",
    "    print(\"   ‚Üí Preparare piani di recruitment intensivo per quell'anno\")\n",
    "\n",
    "print(\"\\nüí° AZIONI CONSIGLIATE:\")\n",
    "print(\"   1. Mappare competenze critiche dei prossimi pensionandi\")\n",
    "print(\"   2. Identificare potenziali successori interni\")\n",
    "print(\"   3. Pianificare programmi di mentoring\")\n",
    "print(\"   4. Valutare trattenimento oltre et√† pensionabile per ruoli chiave\")\n",
    "print(\"   5. Aggiornare job descriptions e requisiti per recruitment\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üìà Report Esecutivo e Raccomandazioni Strategiche\n",
    "\n",
    "**Questa sezione riassume tutti i dati analizzati in insights azionabili per il management.**\n",
    "\n",
    "Perfetto per:\n",
    "- üìã **Presentazioni al board**\n",
    "- üéØ **Definizione obiettivi HR**\n",
    "- üí∞ **Budget planning**\n",
    "- üìä **KPI tracking**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calcolo KPI chiave per il report esecutivo\n",
    "def genera_report_esecutivo(df):\n",
    "    \"\"\"\n",
    "    Genera un report esecutivo con KPI chiave e raccomandazioni\n",
    "    \"\"\"\n",
    "    \n",
    "    # KPI Generali\n",
    "    dipendenti_attivi = df[df['EmploymentStatus'] == 'Active']\n",
    "    total_employees = len(df)\n",
    "    active_employees = len(dipendenti_attivi)\n",
    "    retention_rate = (active_employees / total_employees) * 100\n",
    "    \n",
    "    # Demografia\n",
    "    eta_media = dipendenti_attivi['Eta'].mean()\n",
    "    tenure_media = dipendenti_attivi['AnniServizio'].mean()\n",
    "    \n",
    "    # Retribuzioni\n",
    "    salario_medio = dipendenti_attivi['Salary'].mean()\n",
    "    salario_mediano = dipendenti_attivi['Salary'].median()\n",
    "    \n",
    "    # Performance\n",
    "    performance_counts = dipendenti_attivi['PerformanceScore'].value_counts()\n",
    "    top_performers_pct = 0\n",
    "    if 'Eccellente' in performance_counts.index:\n",
    "        top_performers_pct = (performance_counts['Eccellente'] / len(dipendenti_attivi)) * 100\n",
    "    \n",
    "    # Pensionamenti\n",
    "    prossimi_pensionamenti = len(dipendenti_attivi[dipendenti_attivi['Eta'] >= 62])\n",
    "    pct_prossimi_pensionamenti = (prossimi_pensionamenti / active_employees) * 100\n",
    "    \n",
    "    # Turnover per dipartimento\n",
    "    turnover_per_dept = df.groupby('Department')['EmploymentStatus'].apply(\n",
    "        lambda x: (x != 'Active').sum() / len(x) * 100\n",
    "    )\n",
    "    dept_alto_turnover = turnover_per_dept.idxmax()\n",
    "    turnover_max = turnover_per_dept.max()\n",
    "    \n",
    "    return {\n",
    "        'kpi_generali': {\n",
    "            'dipendenti_attivi': active_employees,\n",
    "            'retention_rate': retention_rate,\n",
    "            'eta_media': eta_media,\n",
    "            'tenure_media': tenure_media\n",
    "        },\n",
    "        'retribuzioni': {\n",
    "            'salario_medio': salario_medio,\n",
    "            'salario_mediano': salario_mediano\n",
    "        },\n",
    "        'performance': {\n",
    "            'top_performers_pct': top_performers_pct\n",
    "        },\n",
    "        'pensionamenti': {\n",
    "            'prossimi_pensionamenti': prossimi_pensionamenti,\n",
    "            'pct_prossimi_pensionamenti': pct_prossimi_pensionamenti\n",
    "        },\n",
    "        'turnover': {\n",
    "            'dept_alto_turnover': dept_alto_turnover,\n",
    "            'turnover_max': turnover_max\n",
    "        }\n",
    "    }\n",
    "\n",
    "# Genera il report\n",
    "report = genera_report_esecutivo(df)\n",
    "\n",
    "print(\"üè¢ REPORT ESECUTIVO HR\")\n",
    "print(\"=\" * 60)\n",
    "print(f\"üìÖ Data Report: {datetime.now().strftime('%d/%m/%Y')}\")\n",
    "print(f\"üìä Periodo Analisi: {df['AnnoAssunzione'].min()} - {df['AnnoAssunzione'].max()}\")\n",
    "\n",
    "print(\"\\nüìä KPI CHIAVE:\")\n",
    "print(\"-\" * 30)\n",
    "print(f\"üë• Dipendenti Attivi: {report['kpi_generali']['dipendenti_attivi']:,}\")\n",
    "print(f\"üìà Retention Rate: {report['kpi_generali']['retention_rate']:.1f}%\")\n",
    "print(f\"üë§ Et√† Media: {report['kpi_generali']['eta_media']:.1f} anni\")\n",
    "print(f\"‚è∞ Tenure Media: {report['kpi_generali']['tenure_media']:.1f} anni\")\n",
    "print(f\"üí∞ Salario Medio: ‚Ç¨{report['retribuzioni']['salario_medio']:,.0f}\")\n",
    "print(f\"‚≠ê Top Performers: {report['performance']['top_performers_pct']:.1f}%\")\n",
    "\n",
    "print(\"\\nüö® ALERT CRITICI:\")\n",
    "print(\"-\" * 30)\n",
    "\n",
    "# Alert basati sui KPI\n",
    "alerts = []\n",
    "\n",
    "if report['kpi_generali']['retention_rate'] < 75:\n",
    "    alerts.append(\"üî¥ Retention rate critico (<75%)\")\n",
    "elif report['kpi_generali']['retention_rate'] < 85:\n",
    "    alerts.append(\"üü° Retention rate sotto la media (<85%)\")\n",
    "\n",
    "if report['pensionamenti']['pct_prossimi_pensionamenti'] > 15:\n",
    "    alerts.append(\"üî¥ Alto rischio pensionamenti (>15% workforce)\")\n",
    "elif report['pensionamenti']['pct_prossimi_pensionamenti'] > 10:\n",
    "    alerts.append(\"üü° Monitorare pensionamenti (>10% workforce)\")\n",
    "\n",
    "if report['turnover']['turnover_max'] > 25:\n",
    "    alerts.append(f\"üî¥ Turnover critico in {report['turnover']['dept_alto_turnover']} ({report['turnover']['turnover_max']:.1f}%)\")\n",
    "\n",
    "if report['performance']['top_performers_pct'] < 10:\n",
    "    alerts.append(\"üü° Pochi top performers (<10%)\")\n",
    "\n",
    "if len(alerts) == 0:\n",
    "    print(\"‚úÖ Nessun alert critico\")\n",
    "else:\n",
    "    for alert in alerts:\n",
    "        print(f\"   {alert}\")\n",
    "\n",
    "print(\"\\nüéØ RACCOMANDAZIONI STRATEGICHE:\")\n",
    "print(\"-\" * 40)\n",
    "\n",
    "raccomandazioni = []\n",
    "\n",
    "# Raccomandazioni basate sui dati\n",
    "if report['kpi_generali']['retention_rate'] < 85:\n",
    "    raccomandazioni.append(\"üíº PRIORIT√Ä ALTA: Implementare programma retention\")\n",
    "    raccomandazioni.append(\"   ‚Üí Exit interviews strutturate\")\n",
    "    raccomandazioni.append(\"   ‚Üí Review compensation & benefits\")\n",
    "    raccomandazioni.append(\"   ‚Üí Programmi employee engagement\")\n",
    "\n",
    "if report['pensionamenti']['pct_prossimi_pensionamenti'] > 10:\n",
    "    raccomandazioni.append(\"üë¥ PRIORIT√Ä ALTA: Succession planning\")\n",
    "    raccomandazioni.append(\"   ‚Üí Mappare competenze critiche\")\n",
    "    raccomandazioni.append(\"   ‚Üí Programmi mentoring\")\n",
    "    raccomandazioni.append(\"   ‚Üí Knowledge transfer strutturato\")\n",
    "\n",
    "if report['performance']['top_performers_pct'] < 15:\n",
    "    raccomandazioni.append(\"‚≠ê Sviluppare programma High Potential\")\n",
    "    raccomandazioni.append(\"   ‚Üí Identificare talenti emergenti\")\n",
    "    raccomandazioni.append(\"   ‚Üí Piani di sviluppo personalizzati\")\n",
    "\n",
    "if report['turnover']['turnover_max'] > 20:\n",
    "    raccomandazioni.append(f\"üîÑ Focus su dipartimento {report['turnover']['dept_alto_turnover']}\")\n",
    "    raccomandazioni.append(\"   ‚Üí Analisi approfondita cause turnover\")\n",
    "    raccomandazioni.append(\"   ‚Üí Review management e cultura\")\n",
    "\n",
    "# Raccomandazioni generali\n",
    "raccomandazioni.extend([\n",
    "    \"üìä Implementare dashboard HR real-time\",\n",
    "    \"üìã Quarterly business review con leadership\",\n",
    "    \"üéØ Definire target KPI per il prossimo anno\",\n",
    "    \"üìà Monitoraggio mensile metriche chiave\"\n",
    "])\n",
    "\n",
    "for i, raccomandazione in enumerate(raccomandazioni, 1):\n",
    "    print(f\"{i:2d}. {raccomandazione}\")\n",
    "\n",
    "print(\"\\nüìã PROSSIMI STEP:\")\n",
    "print(\"-\" * 25)\n",
    "print(\"1. üìÖ Presentare report al leadership team\")\n",
    "print(\"2. üéØ Definire priorit√† e budget per azioni correttive\")\n",
    "print(\"3. üìä Stabilire cadenza review (mensile/trimestrale)\")\n",
    "print(\"4. üîÑ Implementare sistema di monitoraggio continuo\")\n",
    "print(\"5. üìà Definire target miglioramento per prossimo anno\")\n",
    "\n",
    "print(\"\\n\" + \"=\" * 60)\n",
    "print(\"‚úÖ ANALISI HR COMPLETA - FINE REPORT\")\n",
    "print(\"üìß Per domande: contattare il team HR Analytics\")\n",
    "print(\"=\" * 60)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üéì Guida per Manager HR: Come Usare Questi Dati\n",
    "\n",
    "**Congratulazioni!** Hai completato l'analisi completa dei dati HR. Ecco come utilizzare al meglio questi insights:\n",
    "\n",
    "### üìä **Come Leggere i Risultati:**\n",
    "\n",
    "1. **Demografia** ‚Üí Pianifica recruitment e diversity\n",
    "2. **Salari** ‚Üí Review equity e competitivit√†\n",
    "3. **Performance** ‚Üí Identifica training needs\n",
    "4. **Turnover** ‚Üí Priorit√† retention\n",
    "5. **Pensionamenti** ‚Üí Succession planning\n",
    "\n",
    "### üéØ **Azioni Immediate:**\n",
    "\n",
    "- **üî¥ Alert Rossi** = Azione immediata richiesta\n",
    "- **üü° Alert Gialli** = Monitorare attentamente\n",
    "- **‚úÖ Verde** = Situazione sotto controllo\n",
    "\n",
    "### üìÖ **Frequenza di Analisi Consigliata:**\n",
    "\n",
    "- **Mensile:** Turnover, assunzioni, performance alerts\n",
    "- **Trimestrale:** Demografia, salari, satisfaction\n",
    "- **Annuale:** Pensionamenti, succession planning\n",
    "\n",
    "### üí° **Pro Tips per HR Manager:**\n",
    "\n",
    "1. **Condividi con il Leadership:** Usa i grafici nelle presentazioni\n",
    "2. **Benchmarking:** Confronta con industry standards\n",
    "3. **Storytelling:** I dati raccontano la storia della tua azienda\n",
    "4. **Predittivo:** Usa i trend per anticipare problemi\n",
    "\n",
    "---\n",
    "\n",
    "**üöÄ Prossimi Passi:**\n",
    "- Esegui questo notebook ogni mese con dati aggiornati\n",
    "- Crea dashboard automatici per il monitoring\n",
    "- Sviluppa action plans basati sui risultati\n",
    "\n",
    "**‚ùì Hai domande?** Questo notebook √® il tuo alleato per decisioni HR data-driven!"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}