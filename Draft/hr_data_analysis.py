{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# ğŸ“Š Analisi Dati HR: Turnover e Demografia Aziendale\n",
    "\n",
    "## Guida Completa per Manager HR\n",
    "\n",
    "**Creato il:** 18 Luglio 2025  \n",
    "**Destinatari:** Manager HR, Direttori del Personale, Leadership aziendale  \n",
    "**Livello:** Principiante - Non richiede conoscenze tecniche  \n",
    "\n",
    "---\n",
    "\n",
    "### ğŸ¯ **Cosa troverai in questa analisi:**\n",
    "\n",
    "1. **Demografia dei dipendenti** - Chi sono i nostri dipendenti?\n",
    "2. **Analisi salariale** - Come sono distribuite le retribuzioni?\n",
    "3. **Performance aziendale** - Come performano i nostri team?\n",
    "4. **Turnover e retention** - Quanti dipendenti lasciano l'azienda?\n",
    "5. **Previsioni pensionamenti** - Chi andrÃ  in pensione nei prossimi anni?\n",
    "6. **Raccomandazioni strategiche** - Cosa fare con questi dati?\n",
    "\n",
    "### ğŸ’¡ **Come leggere questo notebook:**\n",
    "- **Celle grigie** = Codice (puoi ignorarle, esegui solo con Shift+Enter)\n",
    "- **Testo normale** = Spiegazioni e interpretazioni\n",
    "- **ğŸ“ˆ Grafici** = Visualizzazioni dei dati\n",
    "- **ğŸ” Insights** = Conclusioni pratiche per l'HR\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ğŸ”§ Preparazione dell'Ambiente\n",
    "\n",
    "Prima di iniziare l'analisi, dobbiamo \"preparare i nostri strumenti\". Questa sezione carica le librerie necessarie per l'analisi dei dati.\n",
    "\n",
    "**â— Importante:** Esegui questa cella per prima cosa premendo **Shift+Enter**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Importazione delle librerie per l'analisi dati\n",
    "# (Queste sono come gli \"strumenti\" che useremo per analizzare i dati)\n",
    "\n",
    "import pandas as pd              # Per leggere e manipolare i dati Excel/CSV\n",
    "import numpy as np               # Per calcoli matematici\n",
    "import matplotlib.pyplot as plt  # Per creare grafici\n",
    "import seaborn as sns           # Per grafici piÃ¹ belli e professionali\n",
    "from datetime import datetime   # Per lavorare con le date\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')  # Nasconde messaggi tecnici non importanti\n",
    "\n",
    "# Configurazione per grafici piÃ¹ belli\n",
    "plt.style.use('default')\n",
    "sns.set_palette(\"husl\")\n",
    "plt.rcParams['figure.figsize'] = (12, 6)  # Dimensione standard dei grafici\n",
    "\n",
    "print(\"âœ… Ambiente pronto per l'analisi!\")\n",
    "print(\"ğŸ“Œ Ora puoi procedere con l'analisi dei dati HR.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ğŸ“‚ Caricamento dei Dati HR\n",
    "\n",
    "In questa sezione carichiamo i dati dei dipendenti dal file Excel/CSV. Il sistema Ã¨ progettato per:\n",
    "- âœ… Caricare automaticamente il file \"HR Data.csv\" se presente\n",
    "- âœ… Creare dati di esempio se il file non Ã¨ disponibile\n",
    "- âœ… Pulire automaticamente i dati (correggere errori, formattare date, ecc.)\n",
    "\n",
    "**Per Manager HR:** Non ti preoccupare del codice, concentrati sui risultati!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def carica_dati_hr(percorso_file='HR Data.csv'):\n",
    "    \"\"\"\n",
    "    Carica e prepara i dati HR per l'analisi\n",
    "    \n",
    "    Cosa fa questa funzione:\n",
    "    - Legge il file Excel/CSV con i dati dei dipendenti\n",
    "    - Corregge automaticamente errori comuni nei dati\n",
    "    - Calcola etÃ  e anzianitÃ  di servizio\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # Prova a caricare il file dei dati HR\n",
    "        df = pd.read_csv(percorso_file)\n",
    "        print(f\"âœ… Dati caricati con successo!\")\n",
    "        print(f\"ğŸ“Š Totale dipendenti nel database: {len(df):,}\")\n",
    "        return df\n",
    "    except FileNotFoundError:\n",
    "        print(\"âš ï¸  File 'HR Data.csv' non trovato.\")\n",
    "        print(\"ğŸ² Creazione dati di esempio per la dimostrazione...\")\n",
    "        return crea_dati_esempio()\n",
    "\n",
    "def crea_dati_esempio():\n",
    "    \"\"\"\n",
    "    Crea un dataset di esempio per dimostrazioni\n",
    "    (Simula dati realistici di un'azienda di 300 dipendenti)\n",
    "    \"\"\"\n",
    "    np.random.seed(42)  # Per risultati riproducibili\n",
    "    n_dipendenti = 300\n",
    "    \n",
    "    # Simulazione dati realistici\n",
    "    dati = {\n",
    "        'EmployeeID': range(1, n_dipendenti + 1),\n",
    "        'EmployeeName': [f'Dipendente_{i}' for i in range(1, n_dipendenti + 1)],\n",
    "        'Salary': np.random.normal(45000, 15000, n_dipendenti).astype(int),\n",
    "        'Position': np.random.choice([\n",
    "            'Tecnico Produzione I', 'Tecnico Produzione II', 'Sales Manager',\n",
    "            'Manager Produzione', 'Software Engineer', 'IT Support', \n",
    "            'Data Analyst', 'Database Administrator', 'Network Engineer'\n",
    "        ], n_dipendenti),\n",
    "        'State': np.random.choice(['Milano', 'Roma', 'Torino', 'Napoli', 'Bologna'], n_dipendenti),\n",
    "        'Gender': np.random.choice(['M', 'F'], n_dipendenti),\n",
    "        'MaritalStatus': np.random.choice(['Single', 'Married', 'Divorced', 'Separated', 'Widowed'], n_dipendenti),\n",
    "        'EmploymentStatus': np.random.choice(['Active', 'Voluntarily Terminated', 'Terminated for Cause'], \n",
    "                                           n_dipendenti, p=[0.75, 0.20, 0.05]),\n",
    "        'Department': np.random.choice(['Produzione', 'IT', 'Vendite', 'Ingegneria', 'Amministrazione'], n_dipendenti),\n",
    "        'RecruitmentSource': np.random.choice(['Indeed', 'LinkedIn', 'Google', 'Referral'], n_dipendenti),\n",
    "        'PerformanceScore': np.random.choice(['Eccellente', 'Buono', 'Sufficiente', 'Insufficiente'], \n",
    "                                           n_dipendenti, p=[0.15, 0.70, 0.12, 0.03])\n",
    "    }\n",
    "    \n",
    "    # Generazione date realistiche\n",
    "    date_nascita = []\n",
    "    date_assunzione = []\n",
    "    date_cessazione = []\n",
    "    \n",
    "    for i in range(n_dipendenti):\n",
    "        # Data di nascita (etÃ  tra 25 e 65 anni)\n",
    "        anno_nascita = np.random.randint(1959, 2000)\n",
    "        data_nascita = datetime(anno_nascita, np.random.randint(1, 13), np.random.randint(1, 29))\n",
    "        date_nascita.append(data_nascita.strftime('%d/%m/%Y'))\n",
    "        \n",
    "        # Data di assunzione\n",
    "        anno_assunzione = np.random.randint(2008, 2025)\n",
    "        data_assunzione = datetime(anno_assunzione, np.random.randint(1, 13), np.random.randint(1, 29))\n",
    "        date_assunzione.append(data_assunzione.strftime('%d/%m/%Y'))\n",
    "        \n",
    "        # Data di cessazione (solo per ex-dipendenti)\n",
    "        if dati['EmploymentStatus'][i] != 'Active':\n",
    "            giorni_lavoro = np.random.randint(30, 2000)\n",
    "            data_cessazione = data_assunzione + pd.Timedelta(days=giorni_lavoro)\n",
    "            date_cessazione.append(data_cessazione.strftime('%d/%m/%Y'))\n",
    "        else:\n",
    "            date_cessazione.append(None)\n",
    "    \n",
    "    dati['DateOfBirth'] = date_nascita\n",
    "    dati['HiringDate'] = date_assunzione\n",
    "    dati['TerminationDate'] = date_cessazione\n",
    "    \n",
    "    return pd.DataFrame(dati)\n",
    "\n",
    "# Carica i dati\n",
    "df_raw = carica_dati_hr()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ğŸ§¹ Pulizia e Preparazione dei Dati\n",
    "\n",
    "**PerchÃ© questa fase Ã¨ importante per l'HR:**\n",
    "- I dati \"grezzi\" spesso contengono errori (date scritte male, campi vuoti, etc.)\n",
    "- Dobbiamo standardizzare i formati per fare analisi corrette\n",
    "- Calcoliamo metriche utili come etÃ  attuale e anni di servizio\n",
    "\n",
    "**Cosa fa il codice sotto:**\n",
    "1. Converte le date in formato standard\n",
    "2. Pulisce i dati del genere (M/F)\n",
    "3. Calcola etÃ  e anzianitÃ  di servizio\n",
    "4. Rimuove eventuali dati di satisfaction non disponibili"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def pulisci_dati_hr(df):\n",
    "    \"\"\"\n",
    "    Pulisce e standardizza i dati HR\n",
    "    \n",
    "    Operazioni eseguite:\n",
    "    1. Conversione date in formato standard\n",
    "    2. Pulizia campo Gender\n",
    "    3. Calcolo etÃ  e tenure\n",
    "    4. Rimozione colonne non necessarie\n",
    "    \"\"\"\n",
    "    print(\"ğŸ§¹ Inizio pulizia dati...\")\n",
    "    \n",
    "    # Copia dei dati per non modificare l'originale\n",
    "    df = df.copy()\n",
    "    \n",
    "    # 1. Conversione delle date\n",
    "    df['DateOfBirth'] = pd.to_datetime(df['DateOfBirth'], format='%d/%m/%Y', errors='coerce')\n",
    "    df['HiringDate'] = pd.to_datetime(df['HiringDate'], format='%d/%m/%Y', errors='coerce')\n",
    "    df['TerminationDate'] = pd.to_datetime(df['TerminationDate'], format='%d/%m/%Y', errors='coerce')\n",
    "    \n",
    "    # 2. Pulizia campo Gender\n",
    "    if 'Gender' in df.columns:\n",
    "        df['Gender'] = df['Gender'].str.strip()  # Rimuove spazi\n",
    "        df['Gender'] = df['Gender'].replace({'M ': 'M'})  # Corregge spazi extra\n",
    "        df['Gender'] = df['Gender'].map({'M': 'Maschio', 'F': 'Femmina'})\n",
    "    \n",
    "    # 3. Calcolo etÃ  e anzianitÃ  (al 18 luglio 2025)\n",
    "    oggi = pd.Timestamp('2025-07-18')\n",
    "    df['Eta'] = (oggi - df['DateOfBirth']).dt.days // 365\n",
    "    df['AnniServizio'] = (oggi - df['HiringDate']).dt.days // 365\n",
    "    df['AnnoAssunzione'] = df['HiringDate'].dt.year\n",
    "    \n",
    "    # 4. Rimozione colonne satisfaction (non disponibili)\n",
    "    colonne_da_rimuovere = ['EmployeeSatisfaction', 'EngagementSurvey']\n",
    "    df = df.drop(columns=[col for col in colonne_da_rimuovere if col in df.columns], errors='ignore')\n",
    "    \n",
    "    # 5. Pulizia salari (rimuove valori negativi o irrealistici)\n",
    "    df = df[df['Salary'] > 0]\n",
    "    df = df[df['Salary'] < 500000]  # Rimuove salari irrealistici\n",
    "    \n",
    "    print(f\"âœ… Pulizia completata!\")\n",
    "    print(f\"ğŸ“Š Dati finali: {len(df):,} dipendenti\")\n",
    "    print(f\"ğŸ“… Periodo analizzato: {df['AnnoAssunzione'].min()} - {df['AnnoAssunzione'].max()}\")\n",
    "    \n",
    "    return df\n",
    "\n",
    "# Pulisci i dati\n",
    "df = pulisci_dati_hr(df_raw)\n",
    "\n",
    "# Mostra un'anteprima dei dati puliti\n",
    "print(\"\\nğŸ“‹ Anteprima dati (prime 5 righe):\")\n",
    "print(df[['EmployeeName', 'Department', 'Salary', 'Eta', 'AnniServizio', 'EmploymentStatus']].head())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ğŸ“Š Panoramica Generale dell'Azienda\n",
    "\n",
    "Prima di approfondire le analisi, vediamo i **numeri chiave** della nostra organizzazione. Questi dati ti danno una fotografia immediata dello stato dell'azienda.\n",
    "\n",
    "**ğŸ’¼ Cosa guardare:**\n",
    "- **Dipendenti attivi vs ex-dipendenti** â†’ Tasso di retention\n",
    "- **EtÃ  media** â†’ Pianificazione successioni\n",
    "- **AnzianitÃ  media** â†’ StabilitÃ  workforce\n",
    "- **Distribuzione dipartimenti** â†’ Bilanciamento organizzativo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calcolo statistiche generali\n",
    "totale_dipendenti = len(df)\n",
    "dipendenti_attivi = len(df[df['EmploymentStatus'] == 'Active'])\n",
    "ex_dipendenti = totale_dipendenti - dipendenti_attivi\n",
    "tasso_retention = (dipendenti_attivi / totale_dipendenti) * 100\n",
    "\n",
    "eta_media = df['Eta'].mean()\n",
    "anzianita_media = df['AnniServizio'].mean()\n",
    "salario_medio = df['Salary'].mean()\n",
    "num_dipartimenti = df['Department'].nunique()\n",
    "\n",
    "print(\"ğŸ¢ PANORAMICA AZIENDALE\")\n",
    "print(\"=\" * 50)\n",
    "print(f\"ğŸ‘¥ Totale dipendenti (presente + passato): {totale_dipendenti:,}\")\n",
    "print(f\"âœ… Dipendenti attualmente attivi: {dipendenti_attivi:,}\")\n",
    "print(f\"âŒ Ex-dipendenti: {ex_dipendenti:,}\")\n",
    "print(f\"ğŸ“ˆ Tasso di retention: {tasso_retention:.1f}%\")\n",
    "print()\n",
    "print(f\"ğŸ‘¤ EtÃ  media dipendenti: {eta_media:.1f} anni\")\n",
    "print(f\"â° AnzianitÃ  media: {anzianita_media:.1f} anni\")\n",
    "print(f\"ğŸ’° Salario medio: â‚¬{salario_medio:,.0f}\")\n",
    "print(f\"ğŸ¬ Numero dipartimenti: {num_dipartimenti}\")\n",
    "\n",
    "print(\"\\nğŸ¯ PRIME OSSERVAZIONI:\")\n",
    "if tasso_retention >= 80:\n",
    "    print(\"âœ… Ottimo tasso di retention - i dipendenti tendono a rimanere\")\n",
    "elif tasso_retention >= 70:\n",
    "    print(\"âš ï¸ Tasso di retention nella media - monitorare le uscite\")\n",
    "else:\n",
    "    print(\"ğŸš¨ Tasso di retention basso - problemi di turnover da affrontare\")\n",
    "\n",
    "if eta_media > 45:\n",
    "    print(\"ğŸ‘´ Workforce relativamente matura - pianificare ricambio generazionale\")\n",
    "elif eta_media < 35:\n",
    "    print(\"ğŸ‘¶ Workforce giovane - investire in sviluppo e crescita\")\n",
    "else:\n",
    "    print(\"ğŸ‘¥ EtÃ  bilanciata - buon mix generazionale\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ğŸ‘¥ Analisi Demografica Dettagliata\n",
    "\n",
    "**PerchÃ© Ã¨ importante per l'HR:**\n",
    "- Capire la composizione del nostro team\n",
    "- Identificare squilibri (di genere, etÃ , dipartimenti)\n",
    "- Pianificare politiche di diversity & inclusion\n",
    "- Preparare strategie di recruitment\n",
    "\n",
    "I grafici sotto mostrano **chi sono** i nostri dipendenti."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Creazione dashboard demografico\n",
    "fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n",
    "fig.suptitle('ğŸ‘¥ DASHBOARD DEMOGRAFICO', fontsize=16, fontweight='bold')\n",
    "\n",
    "# 1. Distribuzione per genere\n",
    "if 'Gender' in df.columns:\n",
    "    genere_counts = df['Gender'].value_counts()\n",
    "    axes[0,0].pie(genere_counts.values, labels=genere_counts.index, autopct='%1.1f%%', \n",
    "                  startangle=90, colors=['lightblue', 'lightpink'])\n",
    "    axes[0,0].set_title('Distribuzione per Genere')\n",
    "else:\n",
    "    axes[0,0].text(0.5, 0.5, 'Dati genere\\nnon disponibili', \n",
    "                   ha='center', va='center', transform=axes[0,0].transAxes)\n",
    "    axes[0,0].set_title('Distribuzione per Genere')\n",
    "\n",
    "# 2. Dipendenti per dipartimento\n",
    "dept_counts = df['Department'].value_counts()\n",
    "colors = plt.cm.Set3(np.linspace(0, 1, len(dept_counts)))\n",
    "bars = axes[0,1].barh(dept_counts.index, dept_counts.values, color=colors)\n",
    "axes[0,1].set_title('Dipendenti per Dipartimento')\n",
    "axes[0,1].set_xlabel('Numero Dipendenti')\n",
    "\n",
    "# Aggiungi valori sulle barre\n",
    "for i, bar in enumerate(bars):\n",
    "    width = bar.get_width()\n",
    "    axes[0,1].text(width + 1, bar.get_y() + bar.get_height()/2, \n",
    "                   f'{int(width)}', ha='left', va='center')\n",
    "\n",
    "# 3. Distribuzione etÃ \n",
    "ages = df['Eta'].dropna()\n",
    "axes[1,0].hist(ages, bins=15, color='skyblue', alpha=0.7, edgecolor='navy')\n",
    "axes[1,0].axvline(ages.mean(), color='red', linestyle='--', linewidth=2, \n",
    "                  label=f'EtÃ  media: {ages.mean():.1f} anni')\n",
    "axes[1,0].set_title('Distribuzione EtÃ  Dipendenti')\n",
    "axes[1,0].set_xlabel('EtÃ  (anni)')\n",
    "axes[1,0].set_ylabel('Numero Dipendenti')\n",
    "axes[1,0].legend()\n",
    "axes[1,0].grid(axis='y', alpha=0.3)\n",
    "\n",
    "# 4. Distribuzione anzianitÃ \n",
    "tenure = df['AnniServizio'].dropna()\n",
    "axes[1,1].hist(tenure, bins=15, color='lightgreen', alpha=0.7, edgecolor='darkgreen')\n",
    "axes[1,1].axvline(tenure.mean(), color='red', linestyle='--', linewidth=2, \n",
    "                  label=f'AnzianitÃ  media: {tenure.mean():.1f} anni')\n",
    "axes[1,1].set_title('Distribuzione AnzianitÃ  di Servizio')\n",
    "axes[1,1].set_xlabel('Anni di Servizio')\n",
    "axes[1,1].set_ylabel('Numero Dipendenti')\n",
    "axes[1,1].legend()\n",
    "axes[1,1].grid(axis='y', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Insights demografici\n",
    "print(\"\\nğŸ” INSIGHTS DEMOGRAFICI:\")\n",
    "print(\"=\" * 40)\n",
    "\n",
    "# Analisi genere\n",
    "if 'Gender' in df.columns:\n",
    "    gender_pct = df['Gender'].value_counts(normalize=True) * 100\n",
    "    print(f\"ğŸ‘« Bilanciamento di genere:\")\n",
    "    for gender, pct in gender_pct.items():\n",
    "        print(f\"   â€¢ {gender}: {pct:.1f}%\")\n",
    "\n",
    "# Dipartimento piÃ¹ grande\n",
    "dept_piu_grande = dept_counts.index[0]\n",
    "print(f\"ğŸ¢ Dipartimento piÃ¹ grande: {dept_piu_grande} ({dept_counts.iloc[0]} dipendenti)\")\n",
    "\n",
    "# Fasce etÃ \n",
    "giovani = len(df[df['Eta'] < 30])\n",
    "medi = len(df[(df['Eta'] >= 30) & (df['Eta'] < 50)])\n",
    "senior = len(df[df['Eta'] >= 50])\n",
    "print(f\"ğŸ‘¥ Fasce di etÃ :\")\n",
    "print(f\"   â€¢ Under 30: {giovani} ({giovani/len(df)*100:.1f}%)\")\n",
    "print(f\"   â€¢ 30-50 anni: {medi} ({medi/len(df)*100:.1f}%)\")\n",
    "print(f\"   â€¢ Over 50: {senior} ({senior/len(df)*100:.1f}%)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ğŸ’° Analisi delle Retribuzioni\n",
    "\n",
    "**Cosa ci dice l'analisi salariale:**\n",
    "- **EquitÃ  retributiva** tra dipartimenti e generi\n",
    "- **CompetitivitÃ ** delle nostre offerte\n",
    "- **Outliers** che potrebbero indicare problemi o talenti speciali\n",
    "- **Budget planning** per aumenti e nuove assunzioni\n",
    "\n",
    "**ğŸ¯ Focus per l'HR:** Cerca disparitÃ  che potrebbero creare problemi di retention o equity."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Dashboard analisi salariale\n",
    "fig, axes = plt.subplots(2, 2, figsize=(16, 12))\n",
    "fig.suptitle('ğŸ’° ANALISI RETRIBUZIONI', fontsize=16, fontweight='bold')\n",
    "\n",
    "# 1. Distribuzione generale salari\n",
    "salari = df['Salary']\n",
    "axes[0,0].hist(salari, bins=25, color='gold', alpha=0.7, edgecolor='orange')\n",
    "axes[0,0].axvline(salari.mean(), color='red', linestyle='--', linewidth=2, \n",
    "                  label=f'Media: â‚¬{salari.mean():,.0f}')\n",
    "axes[0,0].axvline(salari.median(), color='blue', linestyle='--', linewidth=2, \n",
    "                  label=f'Mediana: â‚¬{salari.median():,.0f}')\n",
    "axes[0,0].set_title('Distribuzione Salari')\n",
    "axes[0,0].set_xlabel('Salario Annuo (â‚¬)')\n",
    "axes[0,0].set_ylabel('Numero Dipendenti')\n",
    "axes[0,0].legend()\n",
    "axes[0,0].grid(axis='y', alpha=0.3)\n",
    "\n",
    "# 2. Salari per dipartimento (boxplot)\n",
    "df_sorted_dept = df.sort_values('Salary', ascending=False)\n",
    "sns.boxplot(data=df, y='Department', x='Salary', ax=axes[0,1], palette='Set2')\n",
    "axes[0,1].set_title('Distribuzione Salari per Dipartimento')\n",
    "axes[0,1].set_xlabel('Salario Annuo (â‚¬)')\n",
    "\n",
    "# 3. Salario medio per dipartimento\n",
    "salario_per_dept = df.groupby('Department')['Salary'].mean().sort_values(ascending=True)\n",
    "colors = plt.cm.viridis(np.linspace(0, 1, len(salario_per_dept)))\n",
    "bars = axes[1,0].barh(salario_per_dept.index, salario_per_dept.values, color=colors)\n",
    "axes[1,0].set_title('Salario Medio per Dipartimento')\n",
    "axes[1,0].set_xlabel('Salario Medio (â‚¬)')\n",
    "\n",
    "# Aggiungi valori\n",
    "for i, bar in enumerate(bars):\n",
    "    width = bar.get_width()\n",
    "    axes[1,0].text(width + 500, bar.get_y() + bar.get_height()/2, \n",
    "                   f'â‚¬{int(width):,}', ha='left', va='center')\n",
    "\n",
    "# 4. Salario vs EtÃ  (scatter plot)\n",
    "scatter = axes[1,1].scatter(df['Eta'], df['Salary'], c=df['AnniServizio'], \n",
    "                           cmap='viridis', alpha=0.6, s=50)\n",
    "axes[1,1].set_title('Salario vs EtÃ  (colore = anni servizio)')\n",
    "axes[1,1].set_xlabel('EtÃ  (anni)')\n",
    "axes[1,1].set_ylabel('Salario (â‚¬)')\n",
    "plt.colorbar(scatter, ax=axes[1,1], label='Anni di Servizio')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Statistiche salariali dettagliate\n",
    "print(\"\\nğŸ“Š STATISTICHE SALARIALI DETTAGLIATE:\")\n",
    "print(\"=\" * 45)\n",
    "\n",
    "print(f\"ğŸ’° Salario medio aziendale: â‚¬{salari.mean():,.0f}\")\n",
    "print(f\"ğŸ“Š Salario mediano: â‚¬{salari.median():,.0f}\")\n",
    "print(f\"ğŸ“ˆ Salario massimo: â‚¬{salari.max():,.0f}\")\n",
    "print(f\"ğŸ“‰ Salario minimo: â‚¬{salari.min():,.0f}\")\n",
    "print(f\"ğŸ“ Range salariale: â‚¬{salari.max() - salari.min():,.0f}\")\n",
    "\n",
    "print(\"\\nğŸ† TOP 3 DIPARTIMENTI PER SALARIO MEDIO:\")\n",
    "top_salari = salario_per_dept.sort_values(ascending=False).head(3)\n",
    "for i, (dept, salario) in enumerate(top_salari.items(), 1):\n",
    "    print(f\"   {i}. {dept}: â‚¬{salario:,.0f}\")\n",
    "\n",
    "# Analisi disparitÃ  salariali\n",
    "if 'Gender' in df.columns:\n",
    "    print(\"\\nğŸ‘« ANALISI EQUITÃ€ DI GENERE:\")\n",
    "    gender_salary = df.groupby('Gender')['Salary'].agg(['mean', 'median', 'count'])\n",
    "    print(gender_salary.round(0))\n",
    "    \n",
    "    if len(gender_salary) >= 2:\n",
    "        gap = gender_salary['mean'].max() - gender_salary['mean'].min()\n",
    "        gap_pct = (gap / gender_salary['mean'].min()) * 100\n",
    "        print(f\"\\nğŸ“Š Gap salariale di genere: â‚¬{gap:,.0f} ({gap_pct:.1f}%)\")\n",
    "        \n",
    "        if gap_pct > 10:\n",
    "            print(\"ğŸš¨ ALERT: Gap salariale significativo - da investigare\")\n",
    "        elif gap_pct > 5:\n",
    "            print(\"âš ï¸ Gap salariale moderato - monitorare\")\n",
    "        else:\n",
    "            print(\"âœ… Gap salariale contenuto\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## â­ Analisi delle Performance\n",
    "\n",
    "**PerchÃ© analizzare le performance:**\n",
    "- Identificare **top performers** e **dipendenti a rischio**\n",
    "- Verificare se ci sono pattern nei dipartimenti\n",
    "- Collegare performance a retention e salari\n",
    "- Pianificare **programmi di sviluppo** mirati\n",
    "\n",
    "**ğŸ¯ Per l'HR:** Usa questi dati per decisioni su promozioni, formazione e gestione dei talenti."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Dashboard performance\n",
    "fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n",
    "fig.suptitle('â­ ANALISI PERFORMANCE', fontsize=16, fontweight='bold')\n",
    "\n",
    "# 1. Distribuzione performance score\n",
    "perf_counts = df['PerformanceScore'].value_counts()\n",
    "colors = ['green', 'lightgreen', 'orange', 'red']\n",
    "colors = colors[:len(perf_counts)]  # Usa solo i colori necessari\n",
    "\n",
    "bars = axes[0,0].bar(perf_counts.index, perf_counts.values, color=colors, alpha=0.7)\n",
    "axes[0,0].set_title('Distribuzione Performance Score')\n",
    "axes[0,0].set_ylabel('Numero Dipendenti')\n",
    "axes[0,0].tick_params(axis='x', rotation=45)\n",
    "\n",
    "# Aggiungi percentuali\n",
    "total = perf_counts.sum()\n",
    "for bar, count in zip(bars, perf_counts.values):\n",
    "    height = bar.get_height()\n",
    "    axes[0,0].text(bar.get_x() + bar.get_width()/2., height + 1,\n",
    "                   f'{count}\\n({count/total*100:.1f}%)', \n",
    "                   ha='center', va='bottom')\n",
    "\n",
    "# 2. Performance per dipartimento (percentuale)\n",
    "perf_dept = pd.crosstab(df['Department'], df['PerformanceScore'], normalize='index') * 100\n",
    "perf_dept.plot(kind='bar', stacked=True, ax=axes[0,1], \n",
    "               colormap='RdYlGn', rot=45)\n",
    "axes[0,1].set_title('Performance per Dipartimento (%)')\n",
    "axes[0,1].set_ylabel('Percentuale')\n",
    "axes[0,1].legend(title='Performance', bbox_to_anchor=(1.05, 1), loc='upper left')\n",
    "\n",
    "# 3. Performance vs Salario\n",
    "sns.boxplot(data=df, x='PerformanceScore', y='Salary', ax=axes[1,0], palette='viridis')\n",
    "axes[1,0].set_title('Salario per Livello di Performance')\n",
    "axes[1,0].tick_params(axis='x', rotation=45)\n",
    "axes[1,0].set_ylabel('Salario (â‚¬)')\n",
    "\n",
    "# 4. Performance vs Tenure\n",
    "sns.boxplot(data=df, x='PerformanceScore', y='AnniServizio', ax=axes[1,1], palette='plasma')\n",
    "axes[1,1].set_title('AnzianitÃ  per Livello di Performance')\n",
    "axes[1,1].tick_params(axis='x', rotation=45)\n",
    "axes[1,1].set_ylabel('Anni di Servizio')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Analisi performance dettagliata\n",
    "print(\"\\nğŸ¯ ANALISI PERFORMANCE DETTAGLIATA:\")\n",
    "print(\"=\" * 40)\n",
    "\n",
    "# Statistiche generali\n",
    "total_dipendenti = len(df)\n",
    "performance_stats = df['PerformanceScore'].value_counts()\n",
    "print(\"ğŸ“Š Distribuzione Performance:\")\n",
    "for score, count in performance_stats.items():\n",
    "    pct = (count / total_dipendenti) * 100\n",
    "    print(f\"   â€¢ {score}: {count} dipendenti ({pct:.1f}%)\")\n",
    "\n",
    "# Top e bottom performers\n",
    "if 'Eccellente' in performance_stats.index:\n",
    "    top_performers = performance_stats['Eccellente']\n",
    "    print(f\"\\nğŸ† Top Performers (Eccellente): {top_performers} ({top_performers/total_dipendenti*100:.1f}%)\")\n",
    "\n",
    "if 'Insufficiente' in performance_stats.index:\n",
    "    low_performers = performance_stats['Insufficiente']\n",
    "    print(f\"âš ï¸ Performance Insufficiente: {low_performers} ({low_performers/total_dipendenti*100:.1f}%)\")\n",
    "    if low_performers > 0:\n",
    "        print(\"   â†’ Consiglio: Implementare piani di miglioramento\")\n",
    "\n",
    "# Correlazione performance-salario\n",
    "print(\"\\nğŸ’° CORRELAZIONE PERFORMANCE-SALARIO:\")\n",
    "perf_salary = df.groupby('PerformanceScore')['Salary'].mean().sort_values(ascending=False)\n",
    "for score, avg_salary in perf_salary.items():\n",
    "    print(f\"   â€¢ {score}: â‚¬{avg_salary:,.0f} (media)\")\n",
    "\n",
    "# Alert per problemi potenziali\n",
    "print(\"\\nğŸš¨ ALERT E RACCOMANDAZIONI:\")\n",
    "if 'Insufficiente' in performance_stats.index and performance_stats['Insufficiente'] > total_dipendenti * 0.05:\n",
    "    print(\"â— Alto numero di performance insufficienti (>5%)\")\n",
    "    print(\"   â†’ Azione: Review processi di hiring e training\")\n",
    "\n",
    "if 'Eccellente' in performance_stats.index and performance_stats['Eccellente'] < total_dipendenti * 0.10:\n",
    "    print(\"â— Pochi top performers (<10%)\")\n",
    "    print(\"   â†’ Azione: Programmi di sviluppo talenti\")\n",
    "\n",
    "print(\"âœ… Monitorare regolarmente questi KPI per identificare trend\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ğŸ”„ Analisi Turnover e Retention\n",
    "\n",
    "**Il turnover Ã¨ uno dei KPI piÃ¹ critici per l'HR:**\n",
    "- **Costi diretti:** Recruitment, training, onboarding\n",
    "- **Costi indiretti:** Perdita di conoscenza, morale del team\n",
    "- **Indicatore di salute** organizzativa\n",
    "\n",
    "**ğŸ¯ Obiettivo:** Identificare pattern di turnover per azioni preventive."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Funzioni per calcolo turnover\n",
    "def calcola_turnover_annuale(df, anno):\n",
    "    \"\"\"\n",
    "    Calcola il tasso di turnover per un anno specifico\n",
    "    \n",
    "    Formula: (Dipendenti usciti nell'anno / Media dipendenti nell'anno) * 100\n",
    "    \"\"\"\n",
    "    inizio_anno = pd.Timestamp(f\"{anno}-01-01\")\n",
    "    fine_anno = pd.Timestamp(f\"{anno}-12-31\")\n",
    "    \n",
    "    # Dipendenti che hanno lasciato durante l'anno\n",
    "    usciti = df['TerminationDate'].between(inizio_anno, fine_anno, na=False).sum()\n",
    "    \n",
    "    # Calcola headcount medio\n",
    "    hc_inizio = ((df['HiringDate'] <= inizio_anno) & \n",
    "                ((df['TerminationDate'].isna()) | (df['TerminationDate'] >= inizio_anno))).sum()\n",
    "    hc_fine = ((df['HiringDate'] <= fine_anno) & \n",
    "              ((df['TerminationDate'].isna()) | (df['TerminationDate'] >= fine_anno))).sum()\n",
    "    \n",
    "    hc_medio = (hc_inizio + hc_fine) / 2\n",
    "    \n",
    "    return (usciti / hc_medio * 100) if hc_medio > 0 else 0\n",
    "\n",
    "# Dashboard turnover\n",
    "fig, axes = plt.subplots(2, 2, figsize=(16, 12))\n",
    "fig.suptitle('ğŸ”„ ANALISI TURNOVER E RETENTION', fontsize=16, fontweight='bold')\n",
    "\n",
    "# 1. Status occupazionale attuale\n",
    "status_counts = df['EmploymentStatus'].value_counts()\n",
    "colors = ['green', 'orange', 'red']\n",
    "colors = colors[:len(status_counts)]\n",
    "\n",
    "wedges, texts, autotexts = axes[0,0].pie(status_counts.values, labels=status_counts.index, \n",
    "                                         autopct='%1.1f%%', startangle=90, colors=colors)\n",
    "axes[0,0].set_title('Status Occupazionale Attuale')\n",
    "\n",
    "# 2. Turnover per dipartimento\n",
    "turnover_dept = df.groupby('Department')['EmploymentStatus'].apply(\n",
    "    lambda x: (x != 'Active').sum() / len(x) * 100\n",
    ").sort_values(ascending=True)\n",
    "\n",
    "colors_dept = plt.cm.Reds(np.linspace(0.3, 0.9, len(turnover_dept)))\n",
    "bars = axes[0,1].barh(turnover_dept.index, turnover_dept.values, color=colors_dept)\n",
    "axes[0,1].set_title('Tasso Turnover per Dipartimento (%)')\n",
    "axes[0,1].set_xlabel('Turnover Rate (%)')\n",
    "\n",
    "# Aggiungi valori\n",
    "for bar, value in zip(bars, turnover_dept.values):\n",
    "    axes[0,1].text(bar.get_width() + 0.5, bar.get_y() + bar.get_height()/2, \n",
    "                   f'{value:.1f}%', ha='left', va='center')\n",
    "\n",
    "# 3. Trend assunzioni per anno\n",
    "assunzioni_anno = df.groupby('AnnoAssunzione').size()\n",
    "axes[1,0].plot(assunzioni_anno.index, assunzioni_anno.values, \n",
    "               marker='o', linewidth=3, markersize=8, color='blue')\n",
    "axes[1,0].set_title('Trend Assunzioni per Anno')\n",
    "axes[1,0].set_xlabel('Anno')\n",
    "axes[1,0].set_ylabel('Numero Assunzioni')\n",
    "axes[1,0].grid(True, alpha=0.3)\n",
    "\n",
    "# Aggiungi valori sui punti\n",
    "for x, y in zip(assunzioni_anno.index, assunzioni_anno.values):\n",
    "    axes[1,0].annotate(f'{y}', (x, y), textcoords=\"offset points\", \n",
    "                       xytext=(0,10), ha='center')\n",
    "\n",
    "# 4. Tenure distribution per status\n",
    "active_tenure = df[df['EmploymentStatus'] == 'Active']['AnniServizio']\n",
    "terminated_tenure = df[df['EmploymentStatus'] != 'Active']['AnniServizio']\n",
    "\n",
    "axes[1,1].hist([active_tenure, terminated_tenure], bins=12, alpha=0.7, \n",
    "               label=['Attivi', 'Ex-dipendenti'], color=['green', 'red'])\n",
    "axes[1,1].set_title('Distribuzione AnzianitÃ  per Status')\n",
    "axes[1,1].set_xlabel('Anni di Servizio')\n",
    "axes[1,1].set_ylabel('Numero Dipendenti')\n",
    "axes[1,1].legend()\n",
    "axes[1,1].grid(axis='y', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Calcolo turnover annuale\n",
    "print(\"\\nğŸ“Š ANALISI TURNOVER DETTAGLIATA:\")\n",
    "print(\"=\" * 40)\n",
    "\n",
    "# Turnover rate attuale\n",
    "dipendenti_totali = len(df)\n",
    "dipendenti_attivi = len(df[df['EmploymentStatus'] == 'Active'])\n",
    "ex_dipendenti = dipendenti_totali - dipendenti_attivi\n",
    "turnover_totale = (ex_dipendenti / dipendenti_totali) * 100\n",
    "\n",
    "print(f\"ğŸ”„ Turnover Rate Complessivo: {turnover_totale:.1f}%\")\n",
    "print(f\"   â€¢ Dipendenti attuali: {dipendenti_attivi:,}\")\n",
    "print(f\"   â€¢ Ex-dipendenti: {ex_dipendenti:,}\")\n",
    "\n",
    "# Turnover per anno (ultimi anni)\n",
    "print(\"\\nğŸ“… TURNOVER ANNUALE:\")\n",
    "anni_analisi = range(2020, 2025)\n",
    "for anno in anni_analisi:\n",
    "    turnover_anno = calcola_turnover_annuale(df, anno)\n",
    "    print(f\"   â€¢ {anno}: {turnover_anno:.1f}%\")\n",
    "\n",
    "# Top dipartimenti per turnover\n",
    "print(\"\\nğŸ¢ DIPARTIMENTI CON TURNOVER PIÃ™ ALTO:\")\n",
    "top_turnover = turnover_dept.sort_values(ascending=False).head(3)\n",
    "for i, (dept, rate) in enumerate(top_turnover.items(), 1):\n",
    "    print(f\"   {i}. {dept}: {rate:.1f}%\")\n",
    "\n",
    "# Analisi tenure degli ex-dipendenti\n",
    "if len(terminated_tenure) > 0:\n",
    "    print(f\"\\nâ° ANALISI EX-DIPENDENTI:\")\n",
    "    print(f\"   â€¢ AnzianitÃ  media al momento dell'uscita: {terminated_tenure.mean():.1f} anni\")\n",
    "    print(f\"   â€¢ AnzianitÃ  mediana: {terminated_tenure.median():.1f} anni\")\n",
    "    \n",
    "    # Pattern di uscita\n",
    "    early_leavers = (terminated_tenure <= 2).sum()\n",
    "    mid_leavers = ((terminated_tenure > 2) & (terminated_tenure <= 5)).sum()\n",
    "    late_leavers = (terminated_tenure > 5).sum()\n",
    "    \n",
    "    print(f\"   â€¢ Uscite precoci (â‰¤2 anni): {early_leavers} ({early_leavers/len(terminated_tenure)*100:.1f}%)\")\n",
    "    print(f\"   â€¢ Uscite medie (2-5 anni): {mid_leavers} ({mid_leavers/len(terminated_tenure)*100:.1f}%)\")\n",
    "    print(f\"   â€¢ Uscite tardive (>5 anni): {late_leavers} ({late_leavers/len(terminated_tenure)*100:.1f}%)\")\n",
    "\n",
    "# Raccomandazioni\n",
    "print(\"\\nğŸ’¡ RACCOMANDAZIONI:\")\n",
    "if turnover_totale > 20:\n",
    "    print(\"ğŸš¨ Turnover critico (>20%) - Azione immediata necessaria\")\n",
    "    print(\"   â†’ Focus su employee engagement e retention\")\n",
    "elif turnover_totale > 15:\n",
    "    print(\"âš ï¸ Turnover alto (>15%) - Monitorare attentamente\")\n",
    "    print(\"   â†’ Analizzare cause di uscita\")\n",
    "else:\n",
    "    print(\"âœ… Turnover nella norma (<15%)\")\n",
    "\n",
    "if early_leavers > len(terminated_tenure) * 0.4:\n",
    "    print(\"â— Molte uscite precoci - Rivedere onboarding e selezione\")\n",
    "\n",
    "if len(top_turnover) > 0 and top_turnover.iloc[0] > 30:\n",
    "    print(f\"â— Dipartimento {top_turnover.index[0]} ha turnover critico - Investigare cause\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ğŸ‘´ Previsione Pensionamenti\n",
    "\n",
    "**PerchÃ© Ã¨ cruciale per l'HR:**\n",
    "- **Succession Planning** - Preparare i ricambi per posizioni chiave\n",
    "- **Knowledge Transfer** - Non perdere competenze critiche\n",
    "- **Budget Planning** - Costi di recruitment e training\n",
    "- **Workforce Planning** - Mantenere continuitÃ  operativa\n",
    "\n",
    "**ğŸ¯ Focus:** Identifica quando avremo \"ondate\" di pensionamenti."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calcola_pensionamenti_futuri(df, anni_previsione=10, eta_pensione=67):\n",
    "    \"\"\"\n",
    "    Calcola i pensionamenti previsti per i prossimi anni\n",
    "    \n",
    "    Args:\n",
    "    - df: DataFrame con i dati\n",
    "    - anni_previsione: Quanti anni guardare avanti\n",
    "    - eta_pensione: EtÃ  di pensionamento (default 67)\n",
    "    \"\"\"\n",
    "    previsioni = []\n",
    "    anno_base = 2025\n",
    "    \n",
    "    # Solo dipendenti attivi\n",
    "    attivi = df[df['EmploymentStatus'] == 'Active'].copy()\n",
    "    \n",
    "    for offset in range(anni_previsione):\n",
    "        anno = anno_base + offset\n",
    "        fine_anno = pd.Timestamp(f\"{anno}-12-31\")\n",
    "        \n",
    "        # Calcola etÃ  a fine anno\n",
    "        eta_fine_anno = (fine_anno - attivi['DateOfBirth']).dt.days // 365\n",
    "        \n",
    "        # Conta quanti raggiungono l'etÃ  pensionabile\n",
    "        pensionabili = (eta_fine_anno >= eta_pensione).sum()\n",
    "        \n",
    "        previsioni.append({\n",
    "            'Anno': anno,\n",
    "            'Pensionamenti_Previsti': pensionabili\n",
    "        })\n",
    "    \n",
    "    return pd.DataFrame(previsioni)\n",
    "\n",
    "# Calcola previsioni pensionamenti\n",
    "previsioni_pensioni = calcola_pensionamenti_futuri(df)\n",
    "\n",
    "# Dashboard pensionamenti\n",
    "fig, axes = plt.subplots(1, 2, figsize=(16, 6))\n",
    "fig.suptitle('ğŸ‘´ PREVISIONI PENSIONAMENTI', fontsize=16, fontweight='bold')\n",
    "\n",
    "# 1. Grafico pensionamenti futuri\n",
    "bars = axes[0].bar(previsioni_pensioni['Anno'], previsioni_pensioni['Pensionamenti_Previsti'], \n",
    "                   color='lightcoral', alpha=0.8, edgecolor='darkred')\n",
    "axes[0].set_title('Pensionamenti Previsti per Anno')\n",
    "axes[0].set_xlabel('Anno')\n",
    "axes[0].set_ylabel('Numero Pensionamenti')\n",
    "axes[0].grid(axis='y', alpha=0.3)\n",
    "\n",
    "# Aggiungi valori sulle barre\n",
    "for bar in bars:\n",
    "    height = bar.get_height()\n",
    "    if height > 0:\n",
    "        axes[0].text(bar.get_x() + bar.get_width()/2., height + 0.1,\n",
    "                     f'{int(height)}', ha='center', va='bottom', fontweight='bold')\n",
    "\n",
    "# 2. Distribuzione etÃ  attuale con soglia pensione\n",
    "dipendenti_attivi = df[df['EmploymentStatus'] == 'Active']\n",
    "eta_attivi = dipendenti_attivi['Eta'].dropna()\n",
    "\n",
    "axes[1].hist(eta_attivi, bins=20, alpha=0.7, color='skyblue', edgecolor='navy')\n",
    "axes[1].axvline(x=67, color='red', linestyle='--', linewidth=3, \n",
    "                label='EtÃ  Pensionamento (67 anni)')\n",
    "axes[1].axvline(x=eta_attivi.mean(), color='orange', linestyle='--', linewidth=2, \n",
    "                label=f'EtÃ  Media ({eta_attivi.mean():.1f} anni)')\n",
    "axes[1].set_title('Distribuzione EtÃ  Dipendenti Attivi')\n",
    "axes[1].set_xlabel('EtÃ  (anni)')\n",
    "axes[1].set_ylabel('Numero Dipendenti')\n",
    "axes[1].legend()\n",
    "axes[1].grid(axis='y', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Analisi dettagliata pensionamenti\n",
    "print(\"\\nğŸ‘´ ANALISI PENSIONAMENTI DETTAGLIATA:\")\n",
    "print(\"=\" * 45)\n",
    "\n",
    "# Situazione attuale\n",
    "gia_pensionabili = len(dipendenti_attivi[dipendenti_attivi['Eta'] >= 67])\n",
    "prossimi_5_anni = len(dipendenti_attivi[(dipendenti_attivi['Eta'] >= 62) & (dipendenti_attivi['Eta'] < 67)])\n",
    "eta_media_attivi = eta_attivi.mean()\n",
    "\n",
    "print(f\"ğŸ‘¥ Dipendenti attivi totali: {len(dipendenti_attivi):,}\")\n",
    "print(f\"ğŸ¯ GiÃ  in etÃ  pensionabile (â‰¥67 anni): {gia_pensionabili}\")\n",
    "print(f\"â° Prossimi alla pensione (62-66 anni): {prossimi_5_anni}\")\n",
    "print(f\"ğŸ“Š EtÃ  media dipendenti attivi: {eta_media_attivi:.1f} anni\")\n",
    "\n",
    "print(\"\\nğŸ“… PREVISIONI PENSIONAMENTI PER ANNO:\")\n",
    "pensionamenti_totali = 0\n",
    "for _, row in previsioni_pensioni.iterrows():\n",
    "    anno = int(row['Anno'])\n",
    "    pensionamenti = int(row['Pensionamenti_Previsti'])\n",
    "    pensionamenti_totali += pensionamenti\n",
    "    pct_workforce = (pensionamenti / len(dipendenti_attivi)) * 100\n",
    "    print(f\"   â€¢ {anno}: {pensionamenti} pensionamenti ({pct_workforce:.1f}% workforce)\")\n",
    "\n",
    "print(f\"\\nğŸ“Š Totale pensionamenti previsti (10 anni): {pensionamenti_totali}\")\n",
    "print(f\"ğŸ“ˆ % workforce che andrÃ  in pensione: {(pensionamenti_totali/len(dipendenti_attivi)*100):.1f}%\")\n",
    "\n",
    "# Pensionamenti per dipartimento\n",
    "print(\"\\nğŸ¢ PENSIONAMENTI PER DIPARTIMENTO (prossimi 5 anni):\")\n",
    "prossimi_pensionandi = dipendenti_attivi[dipendenti_attivi['Eta'] >= 62]\n",
    "pensioni_per_dept = prossimi_pensionandi.groupby('Department').size().sort_values(ascending=False)\n",
    "\n",
    "for dept, count in pensioni_per_dept.items():\n",
    "    total_dept = len(dipendenti_attivi[dipendenti_attivi['Department'] == dept])\n",
    "    pct = (count / total_dept) * 100\n",
    "    print(f\"   â€¢ {dept}: {count} pensionamenti ({pct:.1f}% del dipartimento)\")\n",
    "\n",
    "# Alert e raccomandazioni\n",
    "print(\"\\nğŸš¨ ALERT E RACCOMANDAZIONI:\")\n",
    "\n",
    "if gia_pensionabili > 0:\n",
    "    print(f\"â— {gia_pensionabili} dipendenti giÃ  in etÃ  pensionabile - Verificare piani di uscita\")\n",
    "\n",
    "if prossimi_5_anni > len(dipendenti_attivi) * 0.15:\n",
    "    print(\"ğŸš¨ CRITICO: >15% dei dipendenti prossimi alla pensione\")\n",
    "    print(\"   â†’ PrioritÃ  assoluta: Succession planning e knowledge transfer\")\n",
    "elif prossimi_5_anni > len(dipendenti_attivi) * 0.10:\n",
    "    print(\"âš ï¸ ATTENZIONE: >10% dei dipendenti prossimi alla pensione\")\n",
    "    print(\"   â†’ Iniziare pianificazione successioni\")\n",
    "\n",
    "# Identifica il \"picco\" di pensionamenti\n",
    "anno_picco = previsioni_pensioni.loc[previsioni_pensioni['Pensionamenti_Previsti'].idxmax(), 'Anno']\n",
    "picco_pensionamenti = previsioni_pensioni['Pensionamenti_Previsti'].max()\n",
    "\n",
    "if picco_pensionamenti > 0:\n",
    "    print(f\"\\nğŸ“ˆ PICCO PENSIONAMENTI: {int(anno_picco)} ({int(picco_pensionamenti)} dipendenti)\")\n",
    "    print(\"   â†’ Preparare piani di recruitment intensivo per quell'anno\")\n",
    "\n",
    "print(\"\\nğŸ’¡ AZIONI CONSIGLIATE:\")\n",
    "print(\"   1. Mappare competenze critiche dei prossimi pensionandi\")\n",
    "print(\"   2. Identificare potenziali successori interni\")\n",
    "print(\"   3. Pianificare programmi di mentoring\")\n",
    "print(\"   4. Valutare trattenimento oltre etÃ  pensionabile per ruoli chiave\")\n",
    "print(\"   5. Aggiornare job descriptions e requisiti per recruitment\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ğŸ“ˆ Report Esecutivo e Raccomandazioni Strategiche\n",
    "\n",
    "**Questa sezione riassume tutti i dati analizzati in insights azionabili per il management.**\n",
    "\n",
    "Perfetto per:\n",
    "- ğŸ“‹ **Presentazioni al board**\n",
    "- ğŸ¯ **Definizione obiettivi HR**\n",
    "- ğŸ’° **Budget planning**\n",
    "- ğŸ“Š **KPI tracking**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calcolo KPI chiave per il report esecutivo\n",
    "def genera_report_esecutivo(df):\n",
    "    \"\"\"\n",
    "    Genera un report esecutivo con KPI chiave e raccomandazioni\n",
    "    \"\"\"\n",
    "    \n",
    "    # KPI Generali\n",
    "    dipendenti_attivi = df[df['EmploymentStatus'] == 'Active']\n",
    "    total_employees = len(df)\n",
    "    active_employees = len(dipendenti_attivi)\n",
    "    retention_rate = (active_employees / total_employees) * 100\n",
    "    \n",
    "    # Demografia\n",
    "    eta_media = dipendenti_attivi['Eta'].mean()\n",
    "    tenure_media = dipendenti_attivi['AnniServizio'].mean()\n",
    "    \n",
    "    # Retribuzioni\n",
    "    salario_medio = dipendenti_attivi['Salary'].mean()\n",
    "    salario_mediano = dipendenti_attivi['Salary'].median()\n",
    "    \n",
    "    # Performance\n",
    "    performance_counts = dipendenti_attivi['PerformanceScore'].value_counts()\n",
    "    top_performers_pct = 0\n",
    "    if 'Eccellente' in performance_counts.index:\n",
    "        top_performers_pct = (performance_counts['Eccellente'] / len(dipendenti_attivi)) * 100\n",
    "    \n",
    "    # Pensionamenti\n",
    "    prossimi_pensionamenti = len(dipendenti_attivi[dipendenti_attivi['Eta'] >= 62])\n",
    "    pct_prossimi_pensionamenti = (prossimi_pensionamenti / active_employees) * 100\n",
    "    \n",
    "    # Turnover per dipartimento\n",
    "    turnover_per_dept = df.groupby('Department')['EmploymentStatus'].apply(\n",
    "        lambda x: (x != 'Active').sum() / len(x) * 100\n",
    "    )\n",
    "    dept_alto_turnover = turnover_per_dept.idxmax()\n",
    "    turnover_max = turnover_per_dept.max()\n",
    "    \n",
    "    return {\n",
    "        'kpi_generali': {\n",
    "            'dipendenti_attivi': active_employees,\n",
    "            'retention_rate': retention_rate,\n",
    "            'eta_media': eta_media,\n",
    "            'tenure_media': tenure_media\n",
    "        },\n",
    "        'retribuzioni': {\n",
    "            'salario_medio': salario_medio,\n",
    "            'salario_mediano': salario_mediano\n",
    "        },\n",
    "        'performance': {\n",
    "            'top_performers_pct': top_performers_pct\n",
    "        },\n",
    "        'pensionamenti': {\n",
    "            'prossimi_pensionamenti': prossimi_pensionamenti,\n",
    "            'pct_prossimi_pensionamenti': pct_prossimi_pensionamenti\n",
    "        },\n",
    "        'turnover': {\n",
    "            'dept_alto_turnover': dept_alto_turnover,\n",
    "            'turnover_max': turnover_max\n",
    "        }\n",
    "    }\n",
    "\n",
    "# Genera il report\n",
    "report = genera_report_esecutivo(df)\n",
    "\n",
    "print(\"ğŸ¢ REPORT ESECUTIVO HR\")\n",
    "print(\"=\" * 60)\n",
    "print(f\"ğŸ“… Data Report: {datetime.now().strftime('%d/%m/%Y')}\")\n",
    "print(f\"ğŸ“Š Periodo Analisi: {df['AnnoAssunzione'].min()} - {df['AnnoAssunzione'].max()}\")\n",
    "\n",
    "print(\"\\nğŸ“Š KPI CHIAVE:\")\n",
    "print(\"-\" * 30)\n",
    "print(f\"ğŸ‘¥ Dipendenti Attivi: {report['kpi_generali']['dipendenti_attivi']:,}\")\n",
    "print(f\"ğŸ“ˆ Retention Rate: {report['kpi_generali']['retention_rate']:.1f}%\")\n",
    "print(f\"ğŸ‘¤ EtÃ  Media: {report['kpi_generali']['eta_media']:.1f} anni\")\n",
    "print(f\"â° Tenure Media: {report['kpi_generali']['tenure_media']:.1f} anni\")\n",
    "print(f\"ğŸ’° Salario Medio: â‚¬{report['retribuzioni']['salario_medio']:,.0f}\")\n",
    "print(f\"â­ Top Performers: {report['performance']['top_performers_pct']:.1f}%\")\n",
    "\n",
    "print(\"\\nğŸš¨ ALERT CRITICI:\")\n",
    "print(\"-\" * 30)\n",
    "\n",
    "# Alert basati sui KPI\n",
    "alerts = []\n",
    "\n",
    "if report['kpi_generali']['retention_rate'] < 75:\n",
    "    alerts.append(\"ğŸ”´ Retention rate critico (<75%)\")\n",
    "elif report['kpi_generali']['retention_rate'] < 85:\n",
    "    alerts.append(\"ğŸŸ¡ Retention rate sotto la media (<85%)\")\n",
    "\n",
    "if report['pensionamenti']['pct_prossimi_pensionamenti'] > 15:\n",
    "    alerts.append(\"ğŸ”´ Alto rischio pensionamenti (>15% workforce)\")\n",
    "elif report['pensionamenti']['pct_prossimi_pensionamenti'] > 10:\n",
    "    alerts.append(\"ğŸŸ¡ Monitorare pensionamenti (>10% workforce)\")\n",
    "\n",
    "if report['turnover']['turnover_max'] > 25:\n",
    "    alerts.append(f\"ğŸ”´ Turnover critico in {report['turnover']['dept_alto_turnover']} ({report['turnover']['turnover_max']:.1f}%)\")\n",
    "\n",
    "if report['performance']['top_performers_pct'] < 10:\n",
    "    alerts.append(\"ğŸŸ¡ Pochi top performers (<10%)\")\n",
    "\n",
    "if len(alerts) == 0:\n",
    "    print(\"âœ… Nessun alert critico\")\n",
    "else:\n",
    "    for alert in alerts:\n",
    "        print(f\"   {alert}\")\n",
    "\n",
    "print(\"\\nğŸ¯ RACCOMANDAZIONI STRATEGICHE:\")\n",
    "print(\"-\" * 40)\n",
    "\n",
    "raccomandazioni = []\n",
    "\n",
    "# Raccomandazioni basate sui dati\n",
    "if report['kpi_generali']['retention_rate'] < 85:\n",
    "    raccomandazioni.append(\"ğŸ’¼ PRIORITÃ€ ALTA: Implementare programma retention\")\n",
    "    raccomandazioni.append(\"   â†’ Exit interviews strutturate\")\n",
    "    raccomandazioni.append(\"   â†’ Review compensation & benefits\")\n",
    "    raccomandazioni.append(\"   â†’ Programmi employee engagement\")\n",
    "\n",
    "if report['pensionamenti']['pct_prossimi_pensionamenti'] > 10:\n",
    "    raccomandazioni.append(\"ğŸ‘´ PRIORITÃ€ ALTA: Succession planning\")\n",
    "    raccomandazioni.append(\"   â†’ Mappare competenze critiche\")\n",
    "    raccomandazioni.append(\"   â†’ Programmi mentoring\")\n",
    "    raccomandazioni.append(\"   â†’ Knowledge transfer strutturato\")\n",
    "\n",
    "if report['performance']['top_performers_pct'] < 15:\n",
    "    raccomandazioni.append(\"â­ Sviluppare programma High Potential\")\n",
    "    raccomandazioni.append(\"   â†’ Identificare talenti emergenti\")\n",
    "    raccomandazioni.append(\"   â†’ Piani di sviluppo personalizzati\")\n",
    "\n",
    "if report['turnover']['turnover_max'] > 20:\n",
    "    raccomandazioni.append(f\"ğŸ”„ Focus su dipartimento {report['turnover']['dept_alto_turnover']}\")\n",
    "    raccomandazioni.append(\"   â†’ Analisi approfondita cause turnover\")\n",
    "    raccomandazioni.append(\"   â†’ Review management e cultura\")\n",
    "\n",
    "# Raccomandazioni generali\n",
    "raccomandazioni.extend([\n",
    "    \"ğŸ“Š Implementare dashboard HR real-time\",\n",
    "    \"ğŸ“‹ Quarterly business review con leadership\",\n",
    "    \"ğŸ¯ Definire target KPI per il prossimo anno\",\n",
    "    \"ğŸ“ˆ Monitoraggio mensile metriche chiave\"\n",
    "])\n",
    "\n",
    "for i, raccomandazione in enumerate(raccomandazioni, 1):\n",
    "    print(f\"{i:2d}. {raccomandazione}\")\n",
    "\n",
    "print(\"\\nğŸ“‹ PROSSIMI STEP:\")\n",
    "print(\"-\" * 25)\n",
    "print(\"1. ğŸ“… Presentare report al leadership team\")\n",
    "print(\"2. ğŸ¯ Definire prioritÃ  e budget per azioni correttive\")\n",
    "print(\"3. ğŸ“Š Stabilire cadenza review (mensile/trimestrale)\")\n",
    "print(\"4. ğŸ”„ Implementare sistema di monitoraggio continuo\")\n",
    "print(\"5. ğŸ“ˆ Definire target miglioramento per prossimo anno\")\n",
    "\n",
    "print(\"\\n\" + \"=\" * 60)\n",
    "print(\"âœ… ANALISI HR COMPLETA - FINE REPORT\")\n",
    "print(\"ğŸ“§ Per domande: contattare il team HR Analytics\")\n",
    "print(\"=\" * 60)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ğŸ“ Guida per Manager HR: Come Usare Questi Dati\n",
    "\n",
    "**Congratulazioni!** Hai completato l'analisi completa dei dati HR. Ecco come utilizzare al meglio questi insights:\n",
    "\n",
    "### ğŸ“Š **Come Leggere i Risultati:**\n",
    "\n",
    "1. **Demografia** â†’ Pianifica recruitment e diversity\n",
    "2. **Salari** â†’ Review equity e competitivitÃ \n",
    "3. **Performance** â†’ Identifica training needs\n",
    "4. **Turnover** â†’ PrioritÃ  retention\n",
    "5. **Pensionamenti** â†’ Succession planning\n",
    "\n",
    "### ğŸ¯ **Azioni Immediate:**\n",
    "\n",
    "- **ğŸ”´ Alert Rossi** = Azione immediata richiesta\n",
    "- **ğŸŸ¡ Alert Gialli** = Monitorare attentamente\n",
    "- **âœ… Verde** = Situazione sotto controllo\n",
    "\n",
    "### ğŸ“… **Frequenza di Analisi Consigliata:**\n",
    "\n",
    "- **Mensile:** Turnover, assunzioni, performance alerts\n",
    "- **Trimestrale:** Demografia, salari, satisfaction\n",
    "- **Annuale:** Pensionamenti, succession planning\n",
    "\n",
    "### ğŸ’¡ **Pro Tips per HR Manager:**\n",
    "\n",
    "1. **Condividi con il Leadership:** Usa i grafici nelle presentazioni\n",
    "2. **Benchmarking:** Confronta con industry standards\n",
    "3. **Storytelling:** I dati raccontano la storia della tua azienda\n",
    "4. **Predittivo:** Usa i trend per anticipare problemi\n",
    "\n",
    "---\n",
    "\n",
    "**ğŸš€ Prossimi Passi:**\n",
    "- Esegui questo notebook ogni mese con dati aggiornati\n",
    "- Crea dashboard automatici per il monitoring\n",
    "- Sviluppa action plans basati sui risultati\n",
    "\n",
    "**â“ Hai domande?** Questo notebook Ã¨ il tuo alleato per decisioni HR data-driven!"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}